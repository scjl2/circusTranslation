\begin{zsection}
  \SECTION GeneratePhase \parents scj\_prelude, Framework, BuildPhase
\end{zsection}

\begin{axdef}
procNameOf : Process \fun N
\end{axdef}

\begin{axdef} 
ControlTierSync : CSExpression \\
MissionSync : CSExpression  \\
SchedulablesSync : CSExpression
\end{axdef}

\begin{axdef}
TierSync : TierEnv  \fun CSExpression \\
\where
\forall t : TierEnv 
\t1 @ \exists m : \{ s : \num \ffun N | \exists i:\num @ dom~s = 1..i \land \forall cluster : t @ \exists name : N @ name \mapsto cluster.1 \in s \} \\
%\t2 | m = \{ s : \num \ffun N | \exists i:\num @ dom~s = 1..i \land \forall cluster : t @ name \mapsto cluster.1 \in s \} \\
\t2 @ TierSync(t) = cs(m)
\end{axdef}

\begin{axdef}
GetMissionID :  ClusterEnv \pfun N
\end{axdef}

\begin{axdef}
GetSOIDs : ClusterEnv \pfun \seq Identifier \cross \seq Identifier \cross \seq Identifier \cross \\ \t1 \seq Identifier \cross \seq Identifier
\end{axdef}

\begin{axdef}
GenerateTiersFWProc : \seq Identifier \cross \seq Identifier \cross \seq Identifier \cross \\
\t1 \seq Identifier \cross \seq Identifier \pfun Process
\end{axdef}

\begin{axdef}
GenerateClusterFWProcs : TierEnv \pfun Process 
\where
\forall tier : TierEnv \\
\t1 | tier \neq \langle \rangle \\
\t1 @ \# tier = 1 \\
\t2 \implies GenerateClusterFWProcs(tier) = \\
\t3 procPar(\\
\t4 procName(GetMissionID(head~tier)), \\
\t4 MissionSync, \\
\t4 GenerateTiersFWProc(GetSOIDs(head~tier) ) \\
\t3) \\
\t1 \land \# tier \geq 1 \\
\t2 \implies GenerateClusterFWProcs(tier) =  \\
\t3 procPar(\\ 
\t4 procPar( \\
\t5 procName( GetMissionID(head~tier) ), \\
\t5 MissionSync, \\
\t5 GenerateTiersFWProc( GetSOIDs(head~tier) ) ),\\
\t4 SchedulablesSync,
\t4 GenerateClusterFWProcs(tail~tier) \\
\t3 )
\end{axdef}

\begin{axdef}
GenerateTierFWProcs : \seq TierEnv \pfun \seq Process
\where
\forall tiers : \seq TierEnv \\
\t1 | tiers \neq \langle \rangle \\
\t1 @ \# tiers = 1 \implies  GenerateTierFWProcs(tiers) = \langle GenerateClusterFWProcs(head~tiers) \rangle \\
\t1 \land \# tiers \geq 1 \implies  \\
\t2 GenerateTierFWProcs(tiers) = \\
\t3 \langle GenerateClusterFWProcs(head~tiers) \rangle \\
\t3 \cat  GenerateTierFWProcs(tail~tiers)
\end{axdef}

\begin{axdef}
GenerateTierFWProc : \seq TierEnv \pfun Process
\end{axdef}

\begin{axdef}
ControlTier : N \\
TopLevelMissionSequencerFWName : N
\end{axdef}

\begin{axdef}
GetParams : Identifier \pfun \seq Expression
\end{axdef}

\begin{axdef}
GenerateFWProcs :  FWEnv \pfun \seq Process
\where
\forall env : FWEnv \\
\t1 | env.2 \neq \langle \rangle \\
\t1 @ \exists fwProc : Process ; controlTierProc : Process ; tierProcs : \seq Process \\
\t2 | fwProc = procPar(procName(ControlTier), TierSync(head~env.2), GenerateTierFWProc(env.2)) \\
\t2 \land controlTierProc = procPar(procName(SafeletFWName), ControlTierSync, 
\\ \t3 procInstP(procName(TopLevelMissionSequencerFWName), GetParams(env.1) )) \\
\t2 \land tierProcs = GenerateTierFWProcs(env.2) \\
\t2 @ GenerateFWProcs(env) = \langle fwProc \rangle \cat \langle controlTierProc \rangle \cat tierProcs
\end{axdef}

\begin{axdef}
GenerateAppTierProcs : TiersAppEnv \pfun Process
\end{axdef}

\begin{axdef}
GenerateAppProc : AppProcEnv \pfun Process
\where
\forall appProcEnv : AppProcEnv  \\
\t1 @ \exists sfAppEnv : AppEnv ; tlmsAppEnv : AppEnv ; tiersAppEnvs : TiersAppEnv \\
\t2 |sfAppEnv = GetSafeletAppEnv(appProcEnv) \\
\t2 \land  tlmsAppEnv = GetTLMSAppEnv(appProcEnv)  \\
\t2 \land tiersAppEnvs = GetTiersAppEnv(appProcEnv) \\
\t2 @ GenerateAppProc(appProcEnv) = \\
\t3 procInter( \\
\t4 procInter(\\
\t5 procInstP(procName(sfAppEnv.1), sfAppEnv.2),\\
\t5 procInstP(procName(tlmsAppEnv.1), tlmsAppEnv.2)\\
\t4 ),\\
\t3 GenerateAppTierProcs(tiersAppEnvs)\\
\t2 ) 
\end{axdef}

\begin{axdef}
Locking : N \\
Threads : N \\
ThreadSync : CSExpression \\
Objects : N
\end{axdef}

\begin{axdef}
BinderCallChan : N \pfun \seq N 
\end{axdef}

\begin{axdef}
NaturalCallChan : N \pfun \seq N 
\end{axdef}

\begin{axdef}
NaturalRetChan : N \pfun \seq N 
\end{axdef}

\begin{axdef}
BindeRetChan : N \pfun \seq N 
\end{axdef}

\begin{axdef}
MCBParams : \seq Type \pfun Expression
\end{axdef}

\begin{axdef}
GenerateMCBChan : BinderMethodEnv \fun CircusParagraph
\where
\forall bme : BinderMethodEnv \\
\t1 @ GenerateMCBChan(bme) = chanDef(\\
\t2 multiDecl(chanNameWithType(BinderCallChan(bme.1), MCBParams(bme.5) ), \\
\t2 multiDecl(chanNameWithType(NaturalCallChan(bme.1), MCBParams(bme.5) ), \\
\t2 multiDecl(chanNameWithType(NaturalRetChan(bme.1), MCBParams(bme.5) ),\\
\t2 scDecl(chanNameWithType(BindeRetChan(bme.1), MCBParams(bme.5) ) ) )))\\
\t1 )
\end{axdef}

\begin{axdef}
MethodCallBinderSync : N \\
GenerateMethodCallBinderSync : \seq  BinderMethodEnv \pfun CircusParagraph
\end{axdef}

\begin{axdef}
GenerateMCBChans : \seq  BinderMethodEnv \fun \seq CircusParagraph
\where
\forall bEnvs : \seq BinderMethodEnv \\
\t1 | bEnvs \neq \langle \rangle \\
\t1 @ \# bEnvs = 1 \implies \\
\t2 GenerateMCBChans(bEnvs) = \langle GenerateMCBChan(head~bEnvs) \rangle \\
\t1 \land \# bEnvs \geq 1 \implies \\
\t2 GenerateMCBChans(bEnvs) = \langle GenerateMCBChan(head~bEnvs) \rangle \\
\t3 \cat GenerateMCBChans(tail~bEnvs)
\end{axdef}

\begin{axdef}
BinderCallComm : N \pfun  N 
\end{axdef}

\begin{axdef}
NaturalCallComm : N \pfun  N 
\end{axdef}

\begin{axdef}
NaturalRetComm : N \pfun  N 
\end{axdef}

\begin{axdef}
BindeRetComm : N \pfun  N 
\end{axdef}

\begin{axdef}
GenerateMCBName : N \pfun N 
\end{axdef}

\begin{axdef}
BinderCallParams : \seq Type \fun \seq CParameter 
\end{axdef}

\begin{axdef}
NaturalCallParams : \seq Type \fun \seq CParameter 
\end{axdef}

\begin{axdef}
NaturalRetParams : \seq Type \fun \seq CParameter 
\end{axdef}

\begin{axdef}
BinderRetParams : \seq Type \fun \seq CParameter 
\end{axdef}

\begin{axdef}
BinderActions : N \\
DoneTLS : Communication \\
NoState : SchemaExp \\
MethodCallBinder : N
\end{axdef}



\begin{axdef}
GenerateMCBAction : BinderMethodEnv \fun PParagraph
\where
\forall bme : BinderMethodEnv \\
\t1 @ GenerateMCBAction(bme) = actDef(GenerateMCBName(bme.1), \\
\t2 prefixExp( (BinderCallComm(bme.1), BinderCallParams(bme.5)), \\
\t3 prefixExp( (NaturalCallComm(bme.1), BinderCallParams(bme.5)), \\
\t4 prefixExp( (NaturalRetComm(bme.1), BinderCallParams(bme.5)), \\
\t5 prefixExp( (BindeRetComm(bme.1), BinderCallParams(bme.5)), \\
\t6 actName( GenerateMCBName(bme.1)) \\
\t5 ) \\
\t4 ) \\
\t3 ) \\
\t2 ) \\
\t1 ) \\
\end{axdef}

\begin{axdef}
GenerateMCBActions : \seq BinderMethodEnv \pfun \seq PParagraph
\where
\forall bEnvs : \seq BinderMethodEnv \\
\t1 | bEnvs \neq \langle \rangle \\
\t1 @ \# bEnvs = 1 \implies \\
\t2 GenerateMCBActions(bEnvs) = \langle GenerateMCBAction(head~bEnvs) \rangle \\
\t1 \land \# bEnvs \geq 1 \implies \\
\t2 GenerateMCBActions(bEnvs) = \langle GenerateMCBAction(head~bEnvs) \rangle \\
\t3 \cat GenerateMCBActions(tail~bEnvs)
\end{axdef}

\begin{axdef}
GenerateMCBProc : \seq BinderMethodEnv \pfun CircusParagraph
\where
\forall bmes : \seq BinderMethodEnv \\
\t1 | bmes \neq \langle \rangle \\
\t1 @ GenerateMCBProc(bmes) = \\
\t2 procDef(pd(MethodCallBinder, \\
\t3 proc (\\
\t4 \langle \rangle, \\
\t4 NoState ,\\
\t4 GenerateMCBActions(bmes) ,\\
\t4 actInterupt(actName(BinderActions), prefixExp(DoneTLS, skip)) \\
\t3 ) \\
\t2 ))
\end{axdef}

\begin{axdef}
GenerateMCBModel : \seq BinderMethodEnv \pfun \seq CircusParagraph
\where
\forall bEnvs : \seq BinderMethodEnv \\
\t1 | bEnvs \neq \langle \rangle \\
\t1 @ GenerateMCBModel(bEnvs) =   GenerateMCBChans(bEnvs) \cat \\
\t2 \langle GenerateMethodCallBinderSync(bEnvs), GenerateMCBProc(bEnvs) \rangle 
\end{axdef}

\begin{axdef}
GenerateThreadProc :  \seq (ThreadIds \cross Priority) \pfun Process \\
\end{axdef} 

\begin{axdef}
GenerateObjectProc : \seq ObjectIds \pfun Process
\end{axdef} 

%LockingEnv == \seq (ThreadIds \cross Priority) \cross \seq ObjectIds
\begin{axdef}
GenerateLockModel: LockingEnv \pfun \seq CircusParagraph
\where
\forall lEnv : LockingEnv \\
\t1 | lEnv.1 \neq \langle \rangle \land lEnv.2 \neq \langle \rangle \\
\t1 @ GenerateLockModel(lEnv) = \\
\t2 \langle\\
\t3 procDef(pd(Locking, procPar(procName(Threads), \\
\t4 ThreadSync, \\
\t4 procName(Objects)))\\
\t3 ), \\
\t3 procDef(pd(Threads, GenerateThreadProc(lEnv.1))), \\
\t3 procDef(pd(Objects, GenerateObjectProc(lEnv.2) )) \\
\t2\rangle 
\end{axdef}
