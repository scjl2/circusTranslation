\begin{zsection}
  \SECTION GeneratePhase \parents scj\_prelude, Framework, BuildPhase
\end{zsection}

\begin{axdef}
procNameOf : Process \fun N
\end{axdef}

\begin{axdef} 
ControlTierSync : CSExpression \\
MissionSync : CSExpression  \\
SchedulablesSync : CSExpression
\end{axdef}

\begin{axdef}
TierSync : TierEnv  \fun CSExpression \\
\where
\forall t : TierEnv \\
\t1 @ \exists m : \seq N \\
%\| m = { s : \num \ffun N | \exists i:\num @ dom~s = 1..i \land \forall cluster : t.Clusters @ \exists name : N @ name \mapsto cluster.Mission \in s \} \\
%\t2 | m = \{ s : \num \ffun N | \exists i:\num @ dom~s = 1..i \land \forall cluster : t @ name \mapsto cluster.1 \in s \} \\
\t2 @ TierSync(t) = cs(m)
\end{axdef}

\begin{axdef}
GetMissionID :  ClusterEnv \pfun N
\end{axdef}

\begin{axdef}
GenerateTiersFWProc : ClusterEnv \pfun Process
\end{axdef}

\begin{axdef}
GenerateClusterFWProcs : \seq ClusterEnv \pfun Process 
\where
\forall clusters : dom~GenerateClusterFWProcs \\
\t1 | clusters \neq \langle \rangle \\
\t1 @ \# clusters = 1 \\
\t2 \implies GenerateClusterFWProcs(clusters) = \\
\t3 procPar(\\
\t4 procName(GetMissionID(head~clusters)), \\
\t4 MissionSync, \\
\t4 GenerateTiersFWProc(head~clusters ) \\
\t3) \\
\t1 \land \# clusters \geq 1 \\
\t2 \implies GenerateClusterFWProcs(clusters) =  \\
\t3 procPar(\\ 
\t4 procPar( \\
\t5 procName( GetMissionID(head~clusters) ), \\
\t5 MissionSync, \\
\t5 GenerateTiersFWProc( head~clusters ) ),\\
\t4 SchedulablesSync, \\
\t4 GenerateClusterFWProcs(tail~clusters) \\
\t3 )
\end{axdef}

\begin{axdef}
GenerateTierFWProcs : \seq TierEnv \pfun \seq Process
\where
\forall tiers : \seq TierEnv \\
\t1 | tiers \neq \langle \rangle \\
\t1 @ \# tiers = 1 \implies  \\
\t2 GenerateTierFWProcs(tiers) = \langle GenerateClusterFWProcs( (head~tiers).Clusters) \rangle \\
\t1 \land \# tiers \geq 1 \implies  \\
\t2 GenerateTierFWProcs(tiers) = \\
\t3 \langle GenerateClusterFWProcs( (head~tiers).Clusters) \rangle \\
\t3 \cat  GenerateTierFWProcs(tail~tiers)
\end{axdef}

\begin{axdef}
GenerateTierFWProc : \seq TierEnv \pfun Process
\end{axdef}

\begin{axdef}
ControlTier : N \\
TopLevelMissionSequencerFWName : N
\end{axdef}

\begin{axdef}
GetParams : Identifier \pfun \seq Expression
\end{axdef}

\begin{axdef}
GenerateFWProcs :  FWEnv \pfun \seq Process
\where
\forall env : FWEnv \\
\t1 | env.Tiers \neq \langle \rangle \\
\t1 @ \exists fwProc : Process ; controlTierProc : Process ; tierProcs : \seq Process \\
\t2 | fwProc = procPar(\\
\t3 procName(ControlTier), \\
\t3 TierSync(head~env.Tiers), \\
\t3 GenerateTierFWProc(env.Tiers)\\
\t2 ) \\
\t2 \land controlTierProc = procPar(\\
\t3 procName(SafeletFWName), \\
\t3 ControlTierSync, \\
\t3 procInstP(procName(TopLevelMissionSequencerFWName), GetParams(env.TopLevelMS) )\\
\t2 ) \\
\t2 \land tierProcs = GenerateTierFWProcs(env.Tiers) \\
\t2 @ GenerateFWProcs(env) = \langle fwProc \rangle \cat \langle controlTierProc \rangle \cat tierProcs
\end{axdef}

\begin{axdef}
GenerateAppTierProcs : \seq TierAppEnv \pfun Process
\end{axdef}

\begin{axdef}
GenerateAppProc : AppProcEnv \pfun Process
\where
\forall appProcEnv : AppProcEnv  \\
\t1 @ \exists sfAppEnv : AppEnv ; tlmsAppEnv : AppEnv ; tiersAppEnvs : \seq TierAppEnv  \\
\t2 |sfAppEnv = GetSafeletAppEnv(appProcEnv) \\
\t2 \land  tlmsAppEnv = GetTLMSAppEnv(appProcEnv)  \\
\t2 \land tiersAppEnvs = GetTiersAppEnv(appProcEnv) \\
\t2 @ GenerateAppProc(appProcEnv) = \\
\t3 procInter( \\
\t4 procInter(\\
\t5 procInstP(procName(sfAppEnv.Name), sfAppEnv.Parameters),\\
\t5 procInstP(procName(tlmsAppEnv.Name), tlmsAppEnv.Parameters)\\
\t4 ),\\
\t3 GenerateAppTierProcs(tiersAppEnvs)\\
\t2 ) 
\end{axdef}

\begin{axdef}
Locking : N \\
Threads : N \\
ThreadSync : CSExpression \\
Objects : N
\end{axdef}

\begin{axdef}
BinderCallChan : N \pfun \seq N 
\end{axdef}

\begin{axdef}
NaturalCallChan : N \pfun \seq N 
\end{axdef}

\begin{axdef}
NaturalRetChan : N \pfun \seq N 
\end{axdef}

\begin{axdef}
BindeRetChan : N \pfun \seq N 
\end{axdef}

\begin{axdef}
MCBParams : \seq Type \pfun Expression
\end{axdef}

\begin{axdef}
GenerateMCBChan : BinderMethodEnv \fun CircusParagraph
\where
\forall bme : BinderMethodEnv \\
\t1 @ GenerateMCBChan(bme) = chanDef(\\
\t2 multiDecl(chanNameWithType(NaturalCallChan(bme.MethodName), \\
\t3 MCBParams(bme.Params) ), \\
\t2 scDecl(chanNameWithType(NaturalRetChan(bme.MethodName), \\
\t3 MCBParams(bme.Params) ) ))\\
\t1 )
\end{axdef}

\begin{axdef}
MethodCallBinderSync : N \\
GenerateMethodCallBinderSync : \seq  BinderMethodEnv \pfun CircusParagraph
\end{axdef}

\begin{axdef}
GenerateMCBChans : \seq  BinderMethodEnv \fun \seq CircusParagraph
\where
\forall bEnvs : \seq BinderMethodEnv \\
\t1 | bEnvs \neq \langle \rangle \\
\t1 @ \# bEnvs = 1 \implies \\
\t2 GenerateMCBChans(bEnvs) = \langle GenerateMCBChan(head~bEnvs) \rangle \\
\t1 \land \# bEnvs \geq 1 \implies \\
\t2 GenerateMCBChans(bEnvs) = \langle GenerateMCBChan(head~bEnvs) \rangle \\
\t3 \cat GenerateMCBChans(tail~bEnvs)
\end{axdef}

\begin{axdef}
BinderCallComm : N \pfun  N 
\end{axdef}

\begin{axdef}
NaturalCallComm : N \pfun  N 
\end{axdef}

\begin{axdef}
NaturalRetComm : N \pfun  N 
\end{axdef}

\begin{axdef}
BindeRetComm : N \pfun  N 
\end{axdef}

\begin{axdef}
GenerateMCBName : N \pfun N 
\end{axdef}

\begin{axdef}
BinderCallParams : \seq Type \fun \seq CParameter 
\end{axdef}

\begin{axdef}
NaturalCallParams : \seq Type \fun \seq CParameter 
\end{axdef}

\begin{axdef}
NaturalRetParams : \seq Type \fun \seq CParameter 
\end{axdef}

\begin{axdef}
BinderRetParams : \seq Type \fun \seq CParameter 
\end{axdef}

\begin{axdef}
BinderActions : N \\
DoneTLS : Communication \\
NoState : SchemaExp \\
MethodCallBinder : N
\end{axdef}



\begin{axdef}
GenerateMCBAction : BinderMethodEnv \fun PParagraph
\where
\forall bme : BinderMethodEnv \\
\t1 @ GenerateMCBAction(bme) = actDef(GenerateMCBName(bme.MethodName), \\
\t2 prefixExp( (BinderCallComm(bme.MethodName), \\
\t4 BinderCallParams(bme.Params)), \\
\t3 prefixExp( (NaturalCallComm(bme.MethodName), \\
\t5 BinderCallParams(bme.Params)), \\
\t4 prefixExp( (NaturalRetComm(bme.MethodName), \\
\t6 BinderCallParams(bme.Params)), \\
\t5 prefixExp( (BindeRetComm(bme.MethodName), \\
\t7 BinderCallParams(bme.Params)), \\
\t6 actName( GenerateMCBName(bme.MethodName)) \\
\t5 ) \\
\t4 ) \\
\t3 ) \\
\t2 ) \\
\t1 ) \\
\end{axdef}

\begin{axdef}
GenerateMCBActions : \seq BinderMethodEnv \pfun \seq PParagraph
\where
\forall bEnvs : \seq BinderMethodEnv \\
\t1 | bEnvs \neq \langle \rangle \\
\t1 @ \# bEnvs = 1 \implies \\
\t2 GenerateMCBActions(bEnvs) = \langle GenerateMCBAction(head~bEnvs) \rangle \\
\t1 \land \# bEnvs \geq 1 \implies \\
\t2 GenerateMCBActions(bEnvs) = \langle GenerateMCBAction(head~bEnvs) \rangle \\
\t3 \cat GenerateMCBActions(tail~bEnvs)
\end{axdef}

\begin{axdef}
GenerateMCBProc : \seq BinderMethodEnv \pfun CircusParagraph
\where
\forall bmes : \seq BinderMethodEnv \\
\t1 | bmes \neq \langle \rangle \\
\t1 @ GenerateMCBProc(bmes) = \\
\t2 procDef(pd(MethodCallBinder, \\
\t3 proc (\\
\t4 \langle \rangle, \\
\t4 NoState ,\\
\t4 GenerateMCBActions(bmes) ,\\
\t4 actInterupt(actName(BinderActions), prefixExp(DoneTLS, skip)) \\
\t3 ) \\
\t2 ))
\end{axdef}

\begin{axdef}
GenerateMCBModel : MCBEnv \pfun \seq CircusParagraph
\where
\forall bEnv : MCBEnv \\
\t1 @ bEnv.BinderMethods = \langle \rangle \implies  GenerateMCBModel(bEnv) = \langle \rangle \\
\t1 \land bEnv.BinderMethods \neq \langle \rangle \implies
GenerateMCBModel(bEnv) =   GenerateMCBChans(bEnv.BinderMethods) \cat \\
\t2 \langle GenerateMethodCallBinderSync(bEnv.BinderMethods), GenerateMCBProc(bEnv.BinderMethods) \rangle 
\end{axdef}

\begin{axdef}
GenerateThreadProc :  \seq (ThreadIds \cross Priority) \pfun Process \\
\end{axdef} 

\begin{axdef}
GenerateObjectProc : \seq ObjectIds \pfun Process
\end{axdef} 

%LockingEnv == \seq (ThreadIds \cross Priority) \cross \seq ObjectIds
\begin{axdef}
GenerateLockModel: LockingEnv \pfun \seq CircusParagraph
\where
\forall lEnv : dom~GenerateLockModel \\
\t1 | lEnv.Threads \neq \langle \rangle \land lEnv.Objects \neq \langle \rangle \\
\t1 @ GenerateLockModel(lEnv) = \\
\t2 \langle\\
\t3 procDef(pd(Locking, procPar(procName(Threads), \\
\t4 ThreadSync, \\
\t4 procName(Objects)))\\
\t3 ), \\
\t3 procDef(pd(Threads, GenerateThreadProc(lEnv.Threads))), \\
\t3 procDef(pd(Objects, GenerateObjectProc(lEnv.Objects) )) \\
\t2\rangle 
\end{axdef}
