\begin{comment}
\begin{zsection}
  \SECTION ~ cdx\_anchor\_e\_sh ~ \parents ~ cdx\_anchor\_e\_mh
\end{zsection}
\end{comment}

\subsection{Phase \name{SH}}

The \name{SH} phase is subdivided into four stages.
%
\begin{enumerate}
  \item Encapsulate shared data of sequential handlers.
  \item Encapsulate shared data of concurrent handlers.
  \item Introduce data to realise control mechanisms.
  \item Collect specification of the memory area data.
\end{enumerate}
%
This subdivision refines the account in~\cite{CWWWZ11}. In this section, we discuss the refinement steps in each stage separately. For this, we require specialised high-level laws which are presented in Section~\ref{sec:Patterns}, where we call them `patterns'. We thus have Pattern 1 and Pattern 2 being used in Stage 1, Pattern 3 being used in Stage 2, and Pattern 4 being used in Stage 3. The refinement patterns are expected to be useful in other case studies too, and apply to action shapes emerging in Stage 4 and Stage 5 of the \name{MH} phase.

\pagebreak

\subsubsection{Patterns}
\label{sec:Patterns}

In this section, we present several high-level patterns that are used in the refinements carried out during the \name{SH} phase. We also examine the proof of some of those patterns, or at least sketch out a proof strategy.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Pattern 1}
\label{sec:Pattern1}

The first pattern targets data passing between sequentially executed handlers. It is used in Stage 1 of the \name{SH} phase. The action structure we refine results from the application of the law \thname{seq-to-par-2} which is typically applied during Stage 4 of the \name{MH} phase. We recaptured the shape of this action below.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    (\circmu X \circspot A_1 \circseq c~!~x \then \Skip \circseq sync \then X)
    \also
    \t1 \lpar ns_1 | cs | ns_2 \rpar
    \also
    (\circmu X \circspot c~?~x \then A_2 \circseq sync \then X)
  \circblockclose
  \circhide \lchanset c \rchanset
  \also
  \provwhere ~ \lchanset c, sync \rchanset \subseteq cs \land c \notin \usedC(A_1) \cup \usedC(A_2)
\end{circusaction*}
\end{circusbox}
%
Our target for its refinement is the following action.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circblockopen
      (\circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq c_3 \then \Skip \circseq sync \then X)
      \also
      \t1 \lpar ns_1 | (cs \setdiff \lchanset c \rchanset) \cup \lchanset c_3 \rchanset | ns_2 \rpar
      \also
      (\circmu X \circspot c_3 \then \Skip \circseq c_2~?~x \then A_2 \circseq sync \then X)
    \circblockclose
    \circhide \lchanset c_3 \rchanset
    \also
    \t1 \lpar ns_1 \cup ns_2 | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circvar v : T \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (c_1~?~x \then v := x) ~ ~ \extchoice
        \\
        (c_2~!~v \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \circhide \lchanset c_1, c_2 \rchanset
  \also
  \provwhere ~ \mbox{$c_1$, $c_2$ and $c_3$ are fresh channels}
\end{circusaction*}
\end{circusbox}
%
Initially, the channel $c$ fulfils a dual purpose of controlling execution and passing data between the parallel actions. These concerns are disentangled by the refinement:~data sharing is realised by the typed channels $c_1$ and $c_2$, and the typeless channel $c_3$ establishes the (sequential) flow of execution. It is possible to deal with the control issue separately; for this, we merely aim for the following intermediate refinement.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circblockopen
      (\circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq sync \then X)
      \also
      \t1 \lpar ns_1 | cs \setdiff \lchanset c \rchanset | ns_2 \rpar
      \also
      (\circmu X \circspot c_2~?~x \then A_2 \circseq sync \then X)
    \circblockclose
    \also
    \t1 \lpar ns_1 \cup ns_2 | \lchanset c_1, c_2, sync \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circvar v : T \circspot\\
      \t1
      \circmu X \circspot
      \circblockopen
        (c_1~?~x \then v := x) ~ ~ \extchoice
        \\
        (c_2~!~v \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \also
    \t1 \lpar \emptyset | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot c_1~?~\anyvar \then c_2~?~\anyvar \then \Skip \circseq sync \then X
    \circblockclose
  \circblockclose
  \circhide \lchanset c_1, c_2 \rchanset
  \also
  \provided ~ \mbox{$c_1$ and $c_2$ are fresh channels}
\end{circusaction*}
\end{circusbox}
%
We then, however, require further refinement steps that introduce the control mechanism via a new channel. Thus here, the pattern breaks down into two steps. The advantage of this approach is that we can account for different strategies for designing control. The disadvantage is that it is not clear (yet) to what extent the refinement of control can be automated, and how much guidance by the user is required for automation.

In Pattern 1, there seems moreover not a notable design space for realising the control aspect; hence, we opt for the solution that uses a single law that already embeds the control mechanism via the synchronisation channel $c_3$. Intuitively, we can think of this channel in terms of (abstractly) modelling a software event.
%
\input{seq-share-1.tex}
%
The right-hand action of the resulting parallelism contributes directly to the $MArea$ action. It is worth to examine the proof of this law in more detail as it reveals some common and recurring themes.

\subsubsection*{Proof of Pattern 1}

The proof is done by transforming the left-hand action of the law into the right-hand action using (mostly) elementary refinement laws. We start with the left-hand side of the law.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    (\circmu X \circspot A_1 \circseq c~!~x \then \Skip \circseq sync \then X)
    \also
    \t1 \lpar ns_1 | cs | ns_2 \rpar
    \also
    (\circmu X \circspot c~?~x \then A_2 \circseq sync \then X)
  \circblockclose
  \circhide \lchanset c \rchanset
  \also
  \provwhere ~  \lchanset c, sync \rchanset \subseteq cs \land c \notin \usedC(A_1) \cup \usedC(A_2)
\end{circusaction*}
\end{circusbox}
%
The first step replaces the channel $c$ by two channels $c_1$ and $c_2$. We require a specialised law for this.
%
\input{replace-sync-chan-seq.tex}
%
Strictly, synchronisation on $sync$ is not necessary in the right-hand parallel action. However, including it turns out to simplify subsequent refinement steps. In particular, when the right-hand control fragment is later on decomposed and collapsed with other actions the presence of $sync$ is useful.

\begin{note}
I think the above law can be expressed as a more general, inductively-defined channel replacement procedure. This would make it applicable to a larger number of action shapes. At a glance, there seems to be benefit in such a generalisation but this is still an open issue and subject to future research.
\end{note}

\nid After applying the law we, obtain the following result.
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
  \dd \dots \; \equiv \; \mbox{``application of the law \thname{replace-sync-chan-seq}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      (\circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq sync \then X)
      \also
      \t1 \lpar ns_1 | cs' | ns_2 \rpar
      \also
      (\circmu X \circspot c_2~?~x \then A_2 \circseq sync \then X)
    \circblockclose
    \also
    \t1 \lpar ns_1 \cup ns_2 | \lchanset c_1, c_2, sync \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot c_1~?~x \then c_2~!~x \then \Skip \circseq sync \then X
    \circblockclose
  \circblockclose
  \circhide \lchanset c_1, c_2 \rchanset
  \also
  \provwhere cs' = cs \setdiff \lchanset c \rchanset \; \provand \; \mbox{$c_1$ and $c_2$ are fresh channels}
\end{circusaction*}
\end{circusflow}
%
We observe that the left-hand action of the outer parallelism already has the correct shape for the \emph{intermediate} target. We therefore focus on the right-hand action. Basically, we want to bring it into a form that resembles the desired shape for the $MArea$ action. The strategy for this is to introduce a parallelism in which one action becomes the significant part of $MArea$ and the other action a residual part that exercises control.

Before performing this parallelisation, we encapsulate the shared data in a local variable by virtue of four basic laws \thname{var-intro}, \thname{extract-var-prefix}, \thname{extract-var-seq} and \thname{extract-var-rec} listed in Appendix~\ref{app:circuslaws}. This permits the following refinement steps, applied to the left-hand action of the parallelism.
%
\begin{comment}
\input{var-intro.tex}
\input{extract-var-prefix.tex}
\input{extract-var-seq.tex}
\input{extract-var-rec.tex}
\end{comment}
\addtocounter{circuslawthm}{4}
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circmu X \circspot c_1~?~x \then c_2~!~x \then \Skip \circseq sync \then X
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the law \thname{var-intro}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circmu X \circspot c_1~?~x \then (\circvar v : T \circspot v := x \circseq c_2~!~v \then \Skip) \circseq sync \then X
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the law \thname{extract-var-prefix}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circmu X \circspot (\circvar v : T \circspot c_1~?~x \then v := x \circseq c_2~!~v \then \Skip) \circseq sync \then X)
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the law \thname{extract-var-seq}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circmu X \circspot (\circvar v : T \circspot c_1~?~x \then v := x \circseq c_2~!~v \then \Skip \circseq sync \then X)
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the law \thname{extract-var-rec}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot \circmu X \circspot (c_1~?~x \then v := x \circseq c_2~!~v \then \Skip \circseq sync \then X)
\end{circusaction*}
\end{circusbox}
%
We next refine the body of the recursion introducing the aforementioned parallelism. The slightly more specific laws required for this are listed below; others are included in Appendix~\ref{app:circuslaws}.
\medskip

\nid The following three laws are variations of distributing a prefix into a parallelism~(Law~\textbf{A.24} in \cite{CSW03}).
%
\input{distr-prefix-par-3.tex}
\input{distr-prefix-par-4.tex}
\input{distr-prefix-par-5.tex}
%
The following law is important for the steps that establish the recursive shape of $MArea$.
%
\input{extchoice-par-intro.tex}
%
\begin{comment}
\input{seq-skip-left-intro.tex}
\input{par-skip-intro.tex}
\input{extend-sync-par.tex}
\input{extchoice-comm.tex}
\end{comment}
\addtocounter{circuslawthm}{4}
%
With the above laws we can proceed with the proof as follows.
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
  \circvar v : T \circspot \circmu X \circspot (c_1~?~x \then v := x \circseq c_2~!~v \then \Skip \circseq sync \then X)
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the laws \thname{seq-skip-left-intro} and \thname{distr-prefix-seq}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot \circmu X \circspot (c_1~?~x \then v := x \circseq c_2~!~v \then \Skip \circseq sync \then \Skip) \circseq X
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the laws \thname{seq-skip-left-intro} and \thname{par-skip-intro}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot \circmu X \circspot
  \circblockopen
    c_1~?~x \then v := x \circseq c_2~!~v \then \Skip \circseq sync \then \Skip \circseq
    \\
    \circblockopen
      \highlight{\Skip \lpar \emptyset | \emptyset | \emptyset \rpar \Skip}
    \circblockclose
  \circblockclose
  \circseq X
\end{circusaction*}
\extracircusvspace
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the law \thname{extend-sync-par}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot \circmu X \circspot
  \circblockopen
    c_1~?~x \then v := x \circseq c_2~!~v \then \Skip \circseq sync \then \Skip \circseq
    \\
    \circblockopen
      \Skip \lpar \emptyset | \highlight{\lchanset c_1, c_2 \rchanset} | \emptyset \rpar \Skip
    \circblockclose
  \circblockclose
  \circseq X
\end{circusaction*}
\extracircusvspace
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the law \thname{distr-prefix-par-3}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot \circmu X \circspot
  \circblockopen
    c_1~?~x \then v := x \circseq c_2~!~v \then \Skip \circseq
    \\
    \circblockopen
      \Skip
      \also
      \t1 \lpar \emptyset | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
      \also
      \highlight{sync \then \Skip}
    \circblockclose
  \circblockclose
  \circseq X
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the law \thname{distr-prefix-par-4} and eliminating sequence with $\Skip$''}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot \circmu X \circspot
  \circblockopen
    c_1~?~x \then v := x \circseq
    \\
    \circblockopen
      \circblockopen
        \highlight{c_2~!~v \then \Skip}
      \circblockclose
      \also
      \t1 \lpar \emptyset | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
      \also
      \circblockopen
        \highlight{c_2~?~\anyvar ~ \then ~} sync \then \Skip
      \circblockclose
    \circblockclose
  \circblockclose
  \circseq X
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the laws \thname{extchoice-par-intro} and \thname{extchoice-comm}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot \circmu X \circspot
  \circblockopen
    c_1~?~x \then v := x \circseq
    \\
    \circblockopen
      \circblockopen
        \highlight{c_1~?~x \then v := x} \extchoice c_2~!~v \then \Skip
      \circblockclose
      \also
      \t1 \lpar \emptyset | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
      \also
      \circblockopen
        c_2~?~\anyvar ~ \then ~ sync \then \Skip
      \circblockclose
    \circblockclose
  \circblockclose
  \circseq X
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the law \thname{distr-prefix-par-5}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot \circmu X \circspot
  \circblockopen
    \circblockopen
      \circblockopen
        (\highlight{c_1~?~x \then v := x}) \circseq
        \\
        (c_1~?~x \then v := x \extchoice c_2~!~v \then \Skip)
      \circblockclose
      \also
      \t1 \lpar \highlight{\{v\}} | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
      \also
      \circblockopen
        \highlight{c_1~?~\anyvar ~ \then ~} c_2~?~\anyvar \then sync \then \Skip
      \circblockclose
    \circblockclose
  \circblockclose
  \circseq X
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the laws \thname{extchoice-par-intro} and \thname{extchoice-comm}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot \circmu X \circspot
  \circblockopen
    \circblockopen
      (c_1~?~x \then v := x \extchoice \highlight{c_2~!~v \then \Skip}) \circseq
      \\
      (c_1~?~x \then v := x \extchoice c_2~!~v \then \Skip)
    \circblockclose
    \also
    \t1 \lpar \{v\} | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
    \also
    \circblockopen
      c_1~?~\anyvar \then c_2~?~\anyvar \then sync \then \Skip
    \circblockclose
  \circblockclose
  \circseq X
\end{circusaction*}
\end{circusflow}
%
We now use a specialised law to distribute the recursion into the parallelism. This law is somewhat similar to \name{rec-sync} in \cite{Cav08}, however lock-step progress is achieve by a synchronisation at the start of the recursion rather than the end. We first recapture \name{rec-sync} in \cite{Cav08}, used later on too, and name it \thname{distr-rec-par-1}.
%
\input{distr-rec-par-1.tex}
%
We next give the alternative version that we require for the transformation in the sequel.
%
\input{distr-rec-par-2.tex}
%
The external choice in the left-hand branch of the parallel action is another elaboration we require to use the law. It is not a problem as it is a Hobson's choice in the context of the right-hand parallel action.
\medskip

\nid We thus obtain the following refinement.
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the law \thname{distr-rec-par-2}''}
  \quad \mbox{\underline{Problem}: \red{\emph{What about the provisos $c_1 \notin \usedC(A_3)$?}}}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot
  \circblockopen
    \circblockopen
      \highlight{\circmu X} \circspot
      \circblockopen
        (c_1~?~x \then v := x \extchoice c_2~!~v \then \Skip) \circseq
        \\
        (c_1~?~x \then v := x \extchoice c_2~!~v \then \Skip)
      \circblockclose
      \circseq \highlight{X}
    \circblockclose
    \also
    \t1 \lpar \{v\} | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \highlight{\circmu X} \circspot c_1~?~\anyvar \then c_2~?~\anyvar \then sync \then \highlight{X}
    \circblockclose
  \circblockclose
\end{circusaction*}
\end{circusflow}
%
The application of \thname{extchoice-par-intro} now reveals its purpose of putting the left-hand action of the parallelism into a form $\circmu X \circspot A \circseq A \circseq X$. The following law simplifies it eliminating repeated actions $A$.
%
\input{elim-repeated-seq-rec.tex}
%
We thus obtain the action below in the next refinement step.
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the law \thname{elim-repeated-seq-rec}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circvar v : T \circspot
  \circblockopen
    \circblockopen
      \circmu X \circspot
      \circblockopen
        (c_1~?~x \then v := x) ~ ~ \extchoice
        \\
        (c_2~!~v \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \also
    \t1 \lpar \{v\} | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot ~ c_1~?~\anyvar \then c_2~?~\anyvar \then sync \then X
    \circblockclose
  \circblockclose
\end{circusaction*}
\end{circusflow}
%
The only remaining task is to distribute the local variable block into the left-hand action of the parallelism. This is achieved by the basic laws \thname{distr-var-par} and \thname{var-elim} given in Appendix~\ref{app:circuslaws}. This produces the two parallel fragments of the \emph{intermediate} result presented at the beginning of the section.
%
\begin{comment}
\input{var-elim.tex}
\end{comment}
\addtocounter{circuslawthm}{1}
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd
  \equiv \; \mbox{``application of the laws \thname{distr-var-par} and \thname{var-elim} and adjusting write sets of the parallelism''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circvar v : T \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (c_1~?~x \then v := x) ~ ~ \extchoice
        \\
        (c_2~!~v \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \also
    \t1 \lpar \emptyset | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot ~ c_1~?~\anyvar \then c_2~?~\anyvar \then sync \then X
    \circblockclose
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
The left-hand action of the parallelism now has the desired shape for $MArea$. The right-hand action encapsulates control of execution, however, without any concerns for shared data. This part needs to be further refined by introducing a basic channel to establish the necessary control between the two handlers. Therefore, we ignore the left-hand action for now and continue refining the right-hand action in combination with the parallelism of handlers. The proof tactic as is follows.
%
\begin{enumerate}
  \item Introduce a fresh hidden channel $c_3$ in the control branch and extend its scope.

  \item Decompose the control branch into a parallelism of smaller fragments.

  \item Match and collapse these parallel fragments suitably with the handlers.
\end{enumerate}
%
These steps are fairly straight-forward and do not require specialised laws, apart from step laws to introduce and collapse parallelism. More importantly, they reveal a general strategy for eliminating control fragments.

Below we recapture the current (intermediate) result of the refinement steps so far.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circblockopen
      (\circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq sync \then X)
      \also
      \t1 \lpar ns_1 | cs' | ns_2 \rpar
      \also
      (\circmu X \circspot c_2~?~x \then A_2 \circseq sync \then X)
    \circblockclose
    \also
    \t1 \lpar ns_1 \cup ns_2 | \lchanset c_1, c_2, sync \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circvar v : T \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (c_1~?~x \then v := x) ~ ~ \extchoice
        \\
        (c_2~!~v \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \also
    \t1 \lpar \emptyset | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot ~ c_1~?~\anyvar \then c_2~?~\anyvar \then sync \then X
    \circblockclose
  \circblockclose
  \circhide \lchanset c_1, c_2 \rchanset
  \also
  \provwhere \lchanset c, sync \rchanset \subseteq cs \land c \notin \usedC(A_1) \cup \usedC(A_2) \; \provand
  \also
  cs' = cs \setdiff \lchanset c \rchanset \; \provand \; \mbox{$c_1$ and $c_2$ are fresh channels}
\end{circusaction*}
\end{circusbox}
%
The focus for the remaining part of the proof is the fragment below which we extract from this action.
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circblockopen
      (\circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq sync \then X)
      \also
      \t1 \lpar ns_1 | cs' | ns_2 \rpar
      \also
      (\circmu X \circspot c_2~?~x \then A_2 \circseq sync \then X)
    \circblockclose
    \also
    \t1 \lpar ns_1 \cup ns_2 | \lchanset c_1, c_2, sync \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot ~ c_1~?~\anyvar \then c_2~?~\anyvar \then sync \then X
    \circblockclose
  \circblockclose
\end{circusaction*}
\end{circusflow}
%
Thus, we ignore the middle action which already converged into the desirable shape for $MArea$.
\medskip

\nid We first introduce the typeless control channel $c_3$.
\pagebreak
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
  \dd
  \dots \; \equiv \; \mbox{``introduction of a hidden communication on a new channel $c_3$ and extracting its hiding''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      (\circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq sync \then X)
      \also
      \t1 \lpar ns_1 | cs' | ns_2 \rpar
      \also
      (\circmu X \circspot c_2~?~x \then A_2 \circseq sync \then X)
    \circblockclose
    \also
    \t1 \lpar ns_1 \cup ns_2 | \lchanset c_1, c_2, sync | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot ~ c_1~?~\anyvar \then \highlight{c_3} \then c_2~?~\anyvar \then sync \then X
    \circblockclose
  \circblockclose
  \circhide \lchanset \highlight{c_3} \rchanset
\end{circusaction*}
\end{circusflow}
%
The derivation might use the following law to introduce the prefix at the right place.
%
\input{hidden-sync-intro.tex}
%
The remaining steps merely extract the concealment of $c_3$ from the prefixes, recursion and parallelism using the elementary laws \thname{extract-hide-prefix}, \thname{extract-hide-rec} and \thname{extract-hide-par-right} in Appendix~\ref{app:circuslaws}.

\begin{comment}
\input{extract-hide-prefix.tex}
\input{extract-hide-rec.tex}
\input{extract-hide-par-left.tex}
\input{extract-hide-par-right.tex}
\end{comment}
\addtocounter{circuslawthm}{4}

We once again use (custom) step laws to introduce a parallelism inside the right-hand recursion with the objective of splitting the recursion into a parallelism of two recursions of which each one is collapsed with one of the handlers. Below we just give the result after introducing the parallelism.
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
  \dd
  \refby \; \mbox{``introduction of parallelism using (custom) parallel step laws''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      (\circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq sync \then X)
      \also
      \t1 \lpar ns_1 | cs' | ns_2 \rpar
      \also
      (\circmu X \circspot c_2~?~x \then A_2 \circseq sync \then X)
    \circblockclose
    \also
    \t1 \lpar ns_1 \cup ns_2 | \lchanset c_1, c_2, sync \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot
      \circblockopen
        (\highlight{c_1~?~\anyvar \then \Skip \circseq c_3 \then \Skip \circseq sync \then X})
        \also
        \t1 \lpar \emptyset | \lchanset c_3 \rchanset | \emptyset \rpar
        \also
        (\highlight{c_3 \then \Skip \circseq c_2~?~\anyvar \then \Skip \circseq sync \then X})
      \circblockclose
    \circblockclose
  \circblockclose
  \circhide \lchanset c_3 \rchanset
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \refby \; \mbox{``application of the law \thname{distr-rec-par-1} to distribution the recursion into the parallelism''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      (\circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq sync \then X)
      \also
      \t1 \lpar ns_1 | cs' | ns_2 \rpar
      \also
      (\circmu X \circspot c_2~?~x \then A_2 \circseq sync \then X)
    \circblockclose
    \also
    \t1 \lpar ns_1 \cup ns_2 | \lchanset c_1, c_2, sync \rchanset | \emptyset \rpar
    \also
    \circblockopen
      (\highlight{\circmu X \circspot ~} c_1~?~\anyvar \then \Skip \circseq c_3 \then \Skip \circseq sync \then X)
      \also
      \t1 \lpar \emptyset | \lchanset c_3 \rchanset | \emptyset \rpar
      \also
      (\highlight{\circmu X \circspot ~} c_3 \then \Skip \circseq c_2~?~\anyvar \then \Skip \circseq sync \then X)
    \circblockclose
  \circblockclose
  \circhide \lchanset c_3 \rchanset
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \refby \; \mbox{``reordering parallel actions matching them with a control fragment''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      (\circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq sync \then X)
      \also
      \t1 \lpar ns_1 | \lchanset c_1, sync \rchanset | \emptyset \rpar
      \also
      (\highlight{\circmu X \circspot c_1~?~\anyvar \then \Skip \circseq c_3 \then \Skip \circseq sync \then X})
    \circblockclose
    \also
    \t1 \lpar ns_1 | cs' \cup \lchanset c_3 \rchanset | ns_2 \rpar
    \also
    \circblockopen
      (\circmu X \circspot c_2~?~x \then A_2 \circseq sync \then X)
      \also
      \t1 \lpar ns_2 | \lchanset c_2, sync \rchanset | \emptyset \rpar
      \also
      (\highlight{\circmu X \circspot c_3 \then \Skip \circseq c_2~?~\anyvar \then \Skip \circseq sync \then X})
    \circblockclose
  \circblockclose
  \circhide \lchanset c_3 \rchanset
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \refby \; \mbox{``extracting recursions from both parallelisms~(symmetric law of \thname{distr-rec-par-1})''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \highlight{\circmu X \circspot}
      \circblockopen
        (A_1 \circseq c_1~!~x \then \Skip \circseq sync \then X)
        \also
        \t1 \lpar ns_1 | \lchanset c_1, sync \rchanset | \emptyset \rpar
        \also
        (c_1~?~\anyvar \then \Skip \circseq c_3 \then \Skip \circseq sync \then X)
      \circblockclose
    \circblockclose
    \also
    \t1 \lpar ns_1 | cs' \cup \lchanset c_3 \rchanset | ns_2 \rpar
    \also
    \circblockopen
      \highlight{\circmu X \circspot}
      \circblockopen
        (c_2~?~x \then A_2 \circseq sync \then X)
        \also
        \t1 \lpar ns_2 | \lchanset c_2, sync \rchanset | \emptyset \rpar
        \also
        (c_3 \then \Skip \circseq c_2~?~\anyvar \then \Skip \circseq sync \then X)
      \circblockclose
    \circblockclose
  \circblockclose
  \circhide \lchanset c_3 \rchanset
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \refby \; \mbox{``collapsing of parallel actions using step laws; this exploits that $c_1$, $c_2$ and $c_3$ are fresh''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq c_3 \then \Skip \circseq sync \then X
    \circblockclose
    \also
    \t1 \lpar ns_1 | cs' \cup \lchanset c_3 \rchanset | ns_2 \rpar
    \also
    \circblockopen
      \circmu X \circspot c_3 \then \Skip \circseq c_2~?~x \then A_2 \circseq sync \then X
    \circblockclose
  \circblockclose
  \circhide \lchanset c_3 \rchanset
\end{circusaction*}
\end{circusflow}
%
Injecting the result back into the context of the refined action.
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circblockopen
        \circmu X \circspot A_1 \circseq c_1~!~x \then \Skip \circseq c_3 \then \Skip \circseq sync \then X
      \circblockclose
      \also
      \t1 \lpar ns_1 | cs' \cup \lchanset c_3 \rchanset | ns_2 \rpar
      \also
      \circblockopen
        \circmu X \circspot c_3 \then \Skip \circseq c_2~?~x \then A_2 \circseq sync \then X
      \circblockclose
    \circblockclose
    \circhide \lchanset c_3 \rchanset
    \also
    \t1 \lpar ns_1 \cup ns_2 | \lchanset c_1, c_2 \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circvar v : T \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (c_1~?~x \then v := x) ~ ~ \extchoice
        \\
        (c_2~!~v \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \circhide \lchanset c_1, c_2 \rchanset
  \also
  \provwhere cs' = cs \setdiff \lchanset c \rchanset \; \provand \; \mbox{$c_1$ and $c_2$ are fresh channels}
\end{circusaction*}
\end{circusflow}
%
This is exactly the right-hand side of the law and thus concludes the proof. We next look at a generalisation of this law that furthermore turns out to be required in our case study.

\begin{note}
There is more work that needs to be done in order to justify the application of \thname{distr-rec-par-2}. This law might need to be rephrased, or at least we have to relax some of its provisos.
\end{note}

%An issue may be that we obtain a parallelism of actions that contribute to $MArea$ rather than a single $MArea$ action. So, clearly some additional laws are needed if we want to obtain just a single action corresponding to $MArea$.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Pattern 2}
\label{sec:Pattern2}

In our case study, we may anticipate to apply Pattern 1 three times, mirroring three applications of \thname{seq-to-par-2} in Stage 4 of the \name{MH} phase. It turns out though that \thname{seq-share-1} is too specific to be applied in all three cases where data is passed between sequential handlers. This is due to inhomogeneities introduced in Stage 5, more specifically during the merge sub-step concluding that stage. We consider the fragment
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circmu X \circspot reduce~?~currentFrame~?~state ~ \then
    \\
    \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
    \\
    detect~!~work \then \Skip \circseq sync \then X
  \circblockclose
  \also
  \t1 \lpar \{voxel\_map, work\} | \lchanset sync, detect \rchanset | \emptyset \rpar
  \also
  \circblockopen
    \circmu X \circspot \highlight{detect~?~work} \then \circvar colls1 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
    \\
    \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
    \\
    recColls~!~colls1 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
  \circblockclose
  \also
  \t1 \lpar \emptyset | \lchanset sync, detect, output \rchanset | \emptyset \rpar
  \also
  \circblockopen
    \circmu X \circspot \highlight{detect~?~work} \then \circvar colls2 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
    \\
    \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
    \\
    recColls~!~colls2 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
  \circblockclose
  \also
  \t1 \lpar \emptyset | \lchanset sync, detect, output \rchanset | \emptyset \rpar
  \also
  \circblockopen
    \circmu X \circspot \highlight{detect~?~work} \then \circvar colls3 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
    \\
    \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
    \\
    recColls~!~colls3 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
  \circblockclose
  \also
  \t1 \lpar \emptyset | \lchanset sync, detect, output \rchanset | \emptyset \rpar
  \also
  \circblockopen
    \circmu X \circspot \highlight{detect~?~work} \then \circvar colls4 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
    \\
    \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
    \\
    recColls~!~colls4 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
\end{circusflow}
%
from the $System$ action. The data here is transmitted through the $detect$ channel, however, with \emph{four} synchronising actions at the receiving end. Also the synchronisations on $output$ within the detection handlers are an issue. The sender in this case is the control action $InteractionHandlers$, omitted above.

This highlights the need for further laws to introduce sharing in sequential handler actions. A generalised version of \thname{seq-share-2} accounts for a possible parallelism of handlers concurrently reading the data.
%
\input{seq-share-2.tex}
%
A detailed proof of this law is omitted but is expected to be very similar to the one for \thname{seq-share-1}, up to the point where we match and collapse the control fragment with the handlers actions.
\medskip

\nid Below, we recapture the control fragment that is collapsed in the proof of the law \thname{seq-share-1}.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    (\circmu X \circspot ~ c_1~?~\anyvar \then \Skip \circseq c_3 \then \Skip \circseq sync \then X)
    \also
    \t1 \lpar \emptyset | \lchanset c_3 \rchanset | \emptyset \rpar
    \also
    (\circmu X \circspot ~ c_3 \then \Skip \circseq c_2~?~\anyvar \then \Skip \circseq sync \then X)
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
In the proof of \thname{seq-share-2}, we require an additional step that duplicates the right-hand action using idempotency of parallel composition. The respective law is.
%
\input{idem-par.tex}
%
Using the law, we refine the control fragment before matching and collapsing it with the handlers.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd
  \dots \; \equiv \; \mbox{``multiple applications of the law \thname{idem-par}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    (\circmu X \circspot c_1~?~\anyvar \then \Skip \circseq c_3 \then \Skip \circseq sync \then X)
    \also
    \t1 \lpar \emptyset | \lchanset c_3 \rchanset | \emptyset \rpar
    \also
    (\circmu X \circspot c_3 \then \Skip \circseq c_2~?~\anyvar \then \Skip
    \circseq sync \then X)
    \also
    \t1 \lpar \emptyset | \lchanset c_2, c_3, sync \rchanset | \emptyset \rpar
    \also
    (\circmu X \circspot c_3 \then \Skip \circseq c_2~?~\anyvar \then \Skip
    \circseq sync \then X)
    \also
    \t1 \dots
    \also
    \t1 \lpar \emptyset | \lchanset c_2, c_3, sync \rchanset | \emptyset \rpar
    \also
    (\circmu X \circspot c_3 \then \Skip \circseq c_2~?~\anyvar \then \Skip
    \circseq sync \then X)
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
Hereafter we proceed in essence in the same way as in the proof of \thname{seq-share-1}, reordering the parallelisms to match each control action with a handler action and use step laws to collapse those parallel actions.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Pattern 3}
\label{sec:Pattern3}

The third pattern targets the refinement of the control action $InteractionHandlers$. This will become an issue for Stage 2 of the \name{SH} phase where we encapsulate shared data that is concurrently accessed.
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
  InteractionHandlers ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot detect~?~work \then \circvar colls1, colls2, colls3, colls4 : int \circspot
    \\
    \circblockopen
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls1 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls2 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls3 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls4 := x))
    \circblockclose
    \circseq
    \\
    \circwait 0 \upto SCFP_{TB} \circseq
    \\
    SetCollisionsFromParts(\lbag colls1, colls2, colls3, colls4 \rbag) \circseq
    \\
    output~!~collisions \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
\end{circusflow}
%
This action emerges as a residual control fragment during the refinement in Stage 5 of the \name{MH} phase. Rather than defining a law that applies to actions of the above shape, we formulate a more general law that is more likely to be reusable. It besides abstracts from the actual number of parallel handlers.
%
\input{par-share.tex}
%
We observe that the time budget $\circwait 0 \upto Merge_{TB}$ is removed by the law, assuming that the time budget $\circwait 0 \upto RC_{TB}$ already subsumes the time require for the merge operation. This models a program design in which the merge is done incrementally with each call of a method that records a partial result.

\begin{note}
We could even remove $\circwait 0 \upto Merge_{TB}$ from the left-hand action of the law.
\end{note}

\pagebreak

\nid The law assumes that the merge operation~($SetCollisionsFromParts$ in the {\CDx}) is can be expressed in terms of a sequence $InitOp \circseq MergeOp$. For the {\CDx} refinement, the respective decomposition is as follows.
%
\begin{circusflow}
\nounparsedcolour
\begin{schema*}{InitOp}
  \Delta CDxMHState
\where
  currentFrame' = currentFrame \land state' = state \land voxel\_map' = voxel\_map \land work' = work\\
  \highlight{collisions' = 0}
\end{schema*}
\extracircusvspace
%
\begin{schema*}{MergeOp}
  \Delta CDxMHState\\
  collsbag? : \bag int
\where
  currentFrame' = currentFrame \land state' = state \land voxel\_map' = voxel\_map \land work' = work\\
  \exists s : \seq int | s = items ~ collsbag? @ collisions' = \highlight{collisions ~ + ~} \Sigma ~ s
\end{schema*}
\end{circusflow}
%
The necessary proof is to show that $SetCollisionsFromParts(cb) = InitOp \circseq MergeOp(cb)$. This is not difficult by eliminating the schema sequence using the one-point rule. The reason we require manual decomposition prior to applying the law is that it seems not possible to derive the initialisation and step-wise merge operation automatically, for instance, from $SetCollisionsFromParts$. Thus, this transformation has to be done by the user but in practical terms this should in most cases not be difficult.

The left-hand action of the result of the law contributes to $MArea$. Channels may be renamed and further decomposed during the \name{AR} phase into $Call$ and $Ret$ pairs to correspond to methods in the program. The right-hand action is a control fragment that needs to be decomposed and distributed into the parallelism of handlers. Again, there is an issue of control versus sharing. The law in this case does not attempt to commit to a particular control mechanism but merely designs access to the shared data. The strategy for eliminating the control action is exactly as illustrated in the proof of the law \thname{seq-share-1}.

The proof of \thname{par-share} shall not be discussed in detail here. This is future work for the time being but one may expect similar themes to emerge as in the proofs of the previous laws for refinement patterns.

\subsubsection*{Discussion}

The difference between \thname{seq-share-1} / \thname{seq-share-2}  and \thname{par-share} is that the control action is implicitly eliminated in the former laws whereas in the latter law it persists. We could potentially define a more high-level version of \thname{par-share} that takes the context of the refined action into account and aggregates the elimination of the residual parallelism. But on the other hand, this might restrict applicability of the law in the general case.

The important conclusion we draw is that for modularity, we require a general tactic, preferably automated, to eliminate control actions. There seem three obvious approaches for this.
%
\begin{enumerate}
  \item Define sufficiently high-level laws that do not give rise to such actions in the first place.

  \item Have specialised high-level laws that eliminate them in the context of parallel handler actions.

  \item Have a generic strategy that eliminates them, possibly modulo guidance by the user.
\end{enumerate}
%
In terms of automation, approach (1) and (2) seem most promising. We also see that (2) improves modularity in comparison to (1). In terms of genericity, (3) seems more powerful than the other approaches. I cannot see a clear strategy for approach (3) yet though and there are various open issues, for instance, with regards to the information that the user has to provide during refinement. This is a challenge for future work.

\pagebreak

\nid Below we present a corresponding law for approach (2) to eliminate the control action that emerges from application of the law \thname{par-share}. It applies in the context of $n + 1$ parallel handlers.
%
\input{par-share-control}
%
\nid We observe that the parallel fragment is almost entirely absorbed, apart from a prefix $init \then \Skip$ that we highlighted above. The proof of the law decomposes the control action as illustrated below.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    (\circmu X \circspot init \then start \then \Skip \circseq sync \then X)
    \also
    \t1 \lpar \emptyset | \lchanset start, sync \rchanset | \emptyset \rpar
    \also
    (\circmu X \circspot start \then record~?~\anyvar \then output~?~\anyvar \then \Skip \circseq sync \then X)
    \also
    \t1 \lpar \emptyset | \lchanset start, output, sync \rchanset | \emptyset \rpar
    \also
    (\circmu X \circspot start \then record~?~\anyvar \then output~?~\anyvar \then \Skip \circseq sync \then X)
    \also
    \t1 \dots
    \also
    \t1 \lpar \emptyset | \lchanset start, output, sync \rchanset | \emptyset \rpar
    \also
    (\circmu X \circspot start \then record~?~\anyvar \then output~?~\anyvar \then \Skip \circseq sync \then X)
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
The smaller control fragments that emerge are collapsed, as before, with the handler actions. All of this is justified using step laws. The prefixes $sync \then \Skip$ reveal their use in facilitating distribution of recursions.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Pattern 4}
\label{sec:Pattern4}

This pattern is needed for the refinement in Stage 3 for our case study. Unlike the previous three patterns, which are geared towards the encapsulation of shared data that is already somewhat explicit in the model, Pattern 4 addresses the refinement of a control mechanism. The pattern effectively refines a synchronisation barrier by a mechanism that makes use of shared data. It is capture by two laws:~the first law \thname{sync-barrier-elim} eliminates the synchronisation barrier by virtue of a control action, and the second law \thname{sync-barrier-control} replaces the control action by an action that introduces new shared data and becomes part of the $MArea$ action. This factorisation fosters modularisation of the refinement strategy; whereas \thname{sync-barrier-elim} is universally applied, we may envisage different designs that eliminate the control fragment.
\medskip

\nid Below we present the first law to remove the barrier by virtue of a control action.
%
\input{sync-barrier-elim.tex}

\subsubsection*{Proof of the Law}

The proof of this law can be simplified by proceeding backwards (from the right-hand action) rather then forwards~(from the left-hand action). The essential idea is once again to decompose the control action and collapse it with the handlers. The decomposition of the control fragment is sketched below.
%
\begin{circusflow}
\nounparsedcolour
\begin{circusaction*}
    \circblockopen
      \circmu X \circspot start \then
      \circblockopen
        (notify~!~1 \then \Skip) ~ \interleave
        \\
        (notify~!~2 \then \Skip) ~ \interleave
        \\
        \dots
        \\
        (notify~!~n \then \Skip)
      \circblockclose
      \circseq done \then \Skip \circseq sync \then X
    \circblockclose
\end{circusaction*}
%
\begin{circusaction*}
  \dd \; \equiv \; \mbox{``distribution of recursion and application of suitable parallel step laws''}
\end{circusaction*}
\begin{circusaction*}
  \circblockopen
    (\circmu X \circspot start \then notify~!~1 \then done \circseq sync \then X)
    \also
    \t1 \lpar \emptyset | \lchanset start, done, sync \rchanset | \emptyset \rpar
    \also
    (\circmu X \circspot start \then notify~!~2 \then done \circseq sync \then X)
    \also
    \t2 \dots
    \also
    \t1 \lpar \emptyset | \lchanset start, done, sync \rchanset | \emptyset \rpar
    \also
    (\circmu X \circspot start \then notify~!~n \then done \circseq sync \then X)
  \circblockclose
\end{circusaction*}
\end{circusflow}
%
We omit a detailed account of the derivation. After the decomposed fragments are collapsed with the handler actions, the channel $notify$ is subsequently removed since none of the parallel actions synchronise on it.
\medskip

\nid The second law is used to transform the control action that arises from \thname{sync-barrier-elim} into a program design that uses new shared data.
%
\input{sync-barrier-control.tex}
%
We note that apart from the right hand parallel branch encapsulating the shared data, we also have a left hand parallel branch that contains a parallelism of smaller control fragments. These fragments will have to be decomposed in the refinement strategy and give rise to another synchronisation on the $start$ channel that initialises the $active$ variable prior to starting execution of the parallel handlers. The fragments are very simple though and it should be possible to distribute them (mostly) automatically.

\pagebreak

\nid Finally, we consider a third law that combines the previous two laws. In this law, we implicitly already collapsed four of the five smaller control fragments emerging from the application of \thname{sync-barrier-control}.
%
\input{sync-barrier-design.tex}
%
This law is less modular but more useful in terms of automation. The residual refinement effort consists of distributing the simple control fragment highlighted above. Intuitively, this corresponds to calling an initialisation method on the shared state. We note that one may envisage designs that do not require an initialisation~($notify$ could cater for this too). For such designs the law \thname{sync-barrier-elim} would still be useful, though \thname{sync-barrier-design} is too specific to be applicable. This highlights a general trade-off between modularity and reuse and automation. It is an important insight and lesson learned in this case study.

We note that even in the design law \thname{sync-barrier-design}, additional refinement is still required during the \name{AR} phase to data refine the $active$ component into a class object and to turn the channels $start$ and $notify$ into method call channel pairs. Otherwise, we have now all ingredients to tackle the refinement stages for the \name{SH} phase in our example. We examine them in detail in the remainder of the section.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Stage 1}

Our main objective in Stage 1 to Stage 3 is to encapsulate shared data and provide means for accessing it. In doing so, we tease out the $MArea$ action, and Step 4 transforms it into the precise shape to match the program design. The essence of the refinement steps is mostly the application of the high-level patterns that have been presented in Section~\ref{sec:Patterns}. Our starting point is the $System$ action resulting from \name{MH}.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  System ~ \circdef\\
  \t1
  \circblockopen
    \circblockopen
      \circblockopen
        \color{Red}
        \circblockopen
          \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
          \\
          reduce~!~currentFrame~!~state \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \also
        \color{Red}
        \circblockopen
          \circmu X \circspot reduce~?~currentFrame~?~state ~ \then
          \\
          \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
          \\
          detect~!~work \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect~?~work \then \circvar colls1 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
          \\
          \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
          \\
          recColls~!~colls1 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect~?~work \then \circvar colls2 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
          \\
          \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
          \\
          recColls~!~colls2 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect~?~work \then \circvar colls3 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
          \\
          \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
          \\
          recColls~!~colls3 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect~?~work \then \circvar colls4 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
          \\
          \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
          \\
          recColls~!~colls4 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot output~?~collisions ~ \then
          \\
          \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
          \\
          (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
        \circblockclose
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
      \\
      \t2 \lchanset detect, output, recColls, sync \rchanset | \{collisions\} \rpar
      \also
      InteractionHandlers
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work, collisions\} | \lchanset sync \rchanset | \emptyset \rpar
    \also
    Cycle
  \circblockclose
  \circhide
  \also
  \t2 \lchanset reduce, detect, output, recColls, sync \rchanset
\end{circusaction*}
\end{circusbox}
%
We have flattened the calls to local actions for handlers using the copy rule, though for brevity we keep the calls to $InteractionHandlers$ and $Cycle$ until we require to expand their definitions in Stage 2.

The refinement in this stage applies the laws~\thname{seq-share-1} and \thname{seq-share-2} to the synchronisations on $reduce$ and $detect$, respectively. Above, we have highlighted the target for the first application of \thname{seq-share-1}. This requires some reordering of parallel actions. After applying the law, we also extract channel hiding and isolate the action that contributes to $MArea$ into a separate branch of the top-level parallelism. These supplementary steps can be tedious on the paper but do not pose a challenge to automation.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd \; \equiv \; \mbox{``reordering parallel actions and distributing the hiding of the $reduce$ channel''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circblockopen
        \circblockopen
        \color{Red}
        \circblockopen
          \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
          \\
          reduce~!~currentFrame~!~state \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \also
        \color{Red}
        \circblockopen
          \circmu X \circspot reduce~?~currentFrame~?~state ~ \then
          \\
          \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
          \\
          detect~!~work \then \Skip \circseq sync \then X
        \circblockclose
        \circblockclose
        \also
        \t2 \circhide ~ ~ \lchanset \highlight{reduce} \rchanset
        \also
        \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect~?~work \then \circvar colls1 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
          \\
          \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
          \\
          recColls~!~colls1 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \dots
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
      \\
      \t2 \lchanset detect, output, recColls, sync \rchanset | \{collisions\} \rpar
      \also
      InteractionHandlers
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work, collisions\} | \lchanset sync \rchanset | \emptyset \rpar
%    \also
    Cycle
  \circblockclose
  \circhide
  \also
  \t1 \lchanset detect, output, recColls, sync \rchanset
\end{circusaction*}
%
\begin{circusaction*}
  \dd \; \equiv \; \mbox{``application of the law \thname{seq-share-1} introducing a new typeless channel $\blue{reduce}$''}
\end{circusaction*}
%
\begin{circusaction*}
  \dd
  \circblockopen
    \circblockopen
      \circblockopen
      \circblockopen
      \circblockopen
        \circblockopen
          \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
          \\
          \green{setFrameState}~!~currentFrame~!~state \then \Skip \circseq \blue{reduce} \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \also
        \circblockopen
          \circmu X \circspot \blue{reduce} \then \Skip \circseq \green{getFrameState}~?~currentFrame~?~state ~ \then
          \\
          \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
          \\
          detect~!~work \then \Skip \circseq sync \then X
        \circblockclose
        \circblockclose
        \also
        \t2 \circhide ~ ~ \lchanset \blue{reduce} \rchanset
        \also
        \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset setFrameState, getFrameState \rchanset | \emptyset \rpar
        \also
        \color{Green}
        \circblockopen
          \circvar currentFrame : RawFrame \circspot
          \\
          \circvar state : StateTable \circspot
          \\
          \t1 \circmu X \circspot
          \circblockopen
            (setFrameState~?~v_1~?~v_2 \then currentFrame, state := v_1, v_2) ~ ~ \extchoice
            \\
            (getFrameState~!~currentFrame~!~state \then \Skip)
          \circblockclose
          \circseq X
        \circblockclose
        \circblockclose
        \also
        \t2 \circhide ~ ~ \lchanset setFrameState, getFrameState \rchanset
        \also
        \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \also
        \t1 \dots
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
      \\
      \t2 \lchanset detect, output, recColls, sync \rchanset | \{collisions\} \rpar
      \also
      InteractionHandlers
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work, collisions\} | \lchanset sync \rchanset | \emptyset \rpar
%    \also
    Cycle
  \circblockclose
  \circhide
  \also
  \t1 \lchanset detect, output, recColls, sync \rchanset
\end{circusaction*}
\end{circusbox}
%
We note that the fresh channel $\blue{reduce}$, highlighted in blue, is different from the former existing channel $\highlight{reduce}$, highlighted in red:~whereas $\blue{reduce}$ is typeless, $\red{reduce}$ is of type $RawFrame \times StateTable$.  To emphasise the part of the action that contributes to $MArea$ as well as the underlying channels for shared data access, we use a \green{green} highlight. Next, we reorder the parallelism once again to isolate the sharing action.
%
\begin{circusbox}
\nounparsedcolour
%
\begin{circusaction*}
  \dd \; \equiv \; \mbox{``reordering of parallelism and extraction of hiding using suitable laws''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circblockopen
        \circblockopen
          \circblockopen
            \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
            \\
            \green{setFrameState}~!~currentFrame~!~state \then \Skip \circseq reduce \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
          \also
          \circblockopen
            \circmu X \circspot reduce \then \Skip \circseq \green{getFrameState}~?~currentFrame~?~state ~ \then
            \\
            \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
            \\
            detect~!~work \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
          \also
          \circblockopen
            \circmu X \circspot detect~?~work \then \circvar colls1 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
            \\
            \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
            \\
            recColls~!~colls1 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
          \also
          \circblockopen
            \circmu X \circspot detect~?~work \then \circvar colls2 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
            \\
            \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
            \\
            recColls~!~colls2 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
          \also
          \circblockopen
            \circmu X \circspot detect~?~work \then \circvar colls3 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
            \\
            \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
            \\
            recColls~!~colls3 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
          \also
          \circblockopen
            \circmu X \circspot detect~?~work \then \circvar colls4 : int \circspot \circwait 0 \upto CPC_{TB} \circseq
            \\
            \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
            \\
            recColls~!~colls4 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \emptyset | \lchanset output, sync \rchanset | \emptyset \rpar
          \also
          \circblockopen
            \circmu X \circspot output~?~collisions ~ \then
            \\
            \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
            \\
            (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
          \circblockclose
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
        \\
        \t2 \lchanset detect, output, recColls, sync \rchanset | \{collisions\} \rpar
        \also
        InteractionHandlers
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work, collisions\} | \lchanset sync \rchanset | \emptyset \rpar
%      \also
      Cycle
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work, collisions\} | \lchanset setFrameState, getFrameState \rchanset | \emptyset \rpar
    \also
    \color{Green}
    \circblockopen
      \circvar currentFrame : RawFrame \circspot
      \\
      \circvar state : StateTable \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setFrameState~?~v_1~?~v_2 \then currentFrame, state := v_1, v_2) ~ ~ \extchoice
        \\
        (getFrameState~!~currentFrame~!~state \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \circhide
  \also
  \t1 \lchanset reduce, detect, output, recColls, setFrameState, getFrameState, sync \rchanset
\end{circusaction*}
\end{circusbox}
%
This concludes the application of Pattern 1. We proceed exactly in the same way in order to encapsulate the data passed through the $detect$ channel. The only difference is that we have to apply \thname{seq-share-2} rather than \thname{seq-share-1}, that is the law for Pattern 2. We omit the low-level steps and just give the result here.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd \; \equiv \; \mbox{``application of the law \thname{seq-share-2} including pre- and post-processing transformations''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circblockopen
        \circblockopen
          \circblockopen
            \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
            \\
            \green{setFrameState}~!~currentFrame~!~state \then \Skip \circseq reduce \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
          \also
          \circblockopen
            \circmu X \circspot reduce \then \Skip \circseq \green{getFrameState}~?~currentFrame~?~state ~ \then
            \\
            \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
            \\
            \green{setWork}~!~work \then \Skip \circseq \blue{detect} \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
          \also
          \circblockopen
            \circmu X \circspot \blue{detect} \then \Skip \circseq \green{getWork}~?~work \then \circvar colls1 : int \circspot
            \\
            \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
            \\
            recColls~!~colls1 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
          \also
          \circblockopen
            \circmu X \circspot \blue{detect} \then \Skip \circseq \green{getWork}~?~work \then \circvar colls2 : int \circspot
            \\
            \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
            \\
            recColls~!~colls2 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
          \also
          \circblockopen
            \circmu X \circspot \blue{detect} \then \Skip \circseq \green{getWork}~?~work \then \circvar colls3 : int \circspot
            \\
            \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
            \\
            recColls~!~colls3 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
          \also
          \circblockopen
            \circmu X \circspot\blue{detect} \then \Skip \circseq \green{getWork}~?~work \then \circvar colls4 : int \circspot
            \\
            \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
            \\
            recColls~!~colls4 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
          \circblockclose
          \also
          \t1 \lpar \emptyset | \lchanset output, sync \rchanset | \emptyset \rpar
          \also
          \circblockopen
            \circmu X \circspot output~?~collisions ~ \then
            \\
            \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
            \\
            (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
          \circblockclose
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
        \\
        \t2 \lchanset detect, output, recColls, sync \rchanset | \{collisions\} \rpar
        \also
        InteractionHandlers
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work, collisions\} | \lchanset sync \rchanset | \emptyset \rpar
%      \also
      Cycle
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work, collisions\} |
    \\
    \t2 \lchanset setFrameState, getFrameState, setWork, getWork \rchanset | \emptyset \rpar
    \also
    \circblockopen
    \color{Green}
    \circblockopen
      \circvar currentFrame : RawFrame \circspot
      \\
      \circvar state : StateTable \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setFrameState~?~v_1~?~v_2 \then currentFrame, state := v_1, v_2) ~ ~ \extchoice
        \\
        (getFrameState~!~currentFrame~!~state \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \color{Black}\interleave
    \also
    \color{Green}
    \circblockopen
      \circvar work : Partition \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setWork~?~v \then work := v) ~ ~ \extchoice
        \\
        (getWork~!~work \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \circblockclose
  \circhide
  \also
  \t1 \lchanset reduce, detect, output, recColls, setFrameState, getFrameState, getWork, setWork, sync \rchanset
\end{circusaction*}
\end{circusbox}
%
We note that applying the law for Pattern 2, we have to take into account that $InteractionHandlers$ also synchronises on the $detect$ channel although it is not interested in the value communicated. Hence, for $InteractionHandler$ we obtain the following action as a result of the previous refinement pattern.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  InteractionHandlers ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot \blue{detect} \then \green{getWork}~?~y ~ \then
    \\
    \circvar colls1, colls2, colls3, colls4 : int \circspot
    \\
    \circblockopen
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls1 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls2 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls3 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls4 := x))
    \circblockclose
    \circseq
    \\
    \circwait 0 \upto SCFP_{TB} \circseq
    \\
    SetCollisionsFromParts(\lbag colls1, colls2, colls3, colls4 \rbag) \circseq
    \\
    output~!~collisions \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
Clearly, the value $y$ is not used in the action after the prefix $\green{getWork}~?~y \then A$ above. Since the channel $getWork$ is concealed and $InteractionHandlers$ only synchronises with the $MArea$ fragment on this channel, we can use a noncompositional rule to remove this communication altogether. Intuitively, this is justified by $getWork$ never being blocked and not having an affect on the action's behaviour.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd \dots \; \equiv \; \mbox{``Specialised noncompositional rule to remove channel communication''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circmu X \circspot \blue{detect} ~ \then
    \\
    \circvar colls1, colls2, colls3, colls4 : int \circspot
    \\
    \circblockopen
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls1 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls2 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls3 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls4 := x))
    \circblockclose
    \circseq
    \\
    \circwait 0 \upto SCFP_{TB} \circseq
    \\
    SetCollisionsFromParts(\lbag colls1, colls2, colls3, colls4 \rbag) \circseq
    \\
    output~!~collisions \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
Here, we shall not examine this rule further but merely identify the need for it. Alternatively, we could provide a more specialised version of the \thname{seq-share-2} law; such, however, may not be as reusable as the present version of the law. To compare and evaluate both options further investigation is necessary.

At this point, one may be tempted to apply Pattern 2 yet another time in order to replace the typed $output$ channel. This indeed is possible, module a minor alteration of the law, but it does not produce the desired program design. More specifically, end up with a shared variable $collisions$ that is accessed via get and set operations, modelled by the channels $getColls$ and $setColls$, for instance. This results in a different design where $InteractionHandlers$ collects the partial results but carries out the update to $collisions$ in a single atomic operation. We, however, want to carry out this update incrementally and concurrently during the detection phase. For this reason, Stage 1 is completed here and we look at the refinement of $InteractionHandlers$ in Stage 2 using a different Pattern 3.

\begin{note}
The above discussion hints that there may be cases in which more than one pattern is applicable. Then developer has a to make a choice governed by design objectives for the program. Indeed, the more patterns and laws we provide, the richer the design space is becomes. In practice, constraints may be identified in order to automate design choices; backtracking from future failures may also be envisaged.
\end{note}

\pagebreak

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Stage 2}

In Stage 2 of the \name{SH} phase, we apply Pattern 3. This consists of applying the law \thname{par-share} presented earlier on in Section~\ref{sec:Patterns}. The law cannot be applied immediately; we first have to bring the action $InteractionHandlers$, which is the target for the law application, into a form that matches the left-hand action of the law. After application of the law, more work has to be done to eliminate residual parallel actions by distributing them into the handlers. This gives rise to localising the synchronisation that initialises the shared $collsisions$ variable prior to the parallel detection phase. We discuss each sub-step in detail.

\subsubsection*{Transformation of Application Target}

We first recall the current definition of $InteractionHandlers$ to which we aim to apply the \thname{par-share} law.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  InteractionHandlers ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot detect ~ \then
    \\
    \circvar colls1, colls2, colls3, colls4 : int \circspot
    \\
    \circblockopen
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls1 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls2 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls3 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls4 := x))
    \circblockclose
    \circseq
    \\
    \circwait 0 \upto SCFP_{TB} \circseq
    \\
    SetCollisionsFromParts(\lbag colls1, colls2, colls3, colls4 \rbag) \circseq
    \\
    output~!~collisions \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
The left-hand side of the \thname{par-share} law is recaptured below.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circvar v : T \circspot\\
    \t1
    \circblockopen
      \circmu X \circspot ~ start \then \circwait 0 \upto Init_{TB} \circseq \lschexpract InitOp \rschexpract \circseq
      \\
      \circvar x_1, x_2, \dots, x_n : T \circspot
      \\
      \circblockopen
          (record~?~x \then (\circwait 0 \upto RC_{TB} \circseq x_1 := x)) \circseq
          \\
          (record~?~x \then (\circwait 0 \upto RC_{TB} \circseq x_2 := x)) \circseq
          \\
          \t1 \dots
          \\
          (record~?~x \then (\circwait 0 \upto RC_{TB} \circseq x_n := x))
        \circseq
        \\
        \circwait 0 \upto Merge_{TB} \circseq \lschexpract MergeOp(\lbag x_1, x_2, \dots, x_n \rbag) \rschexpract \circseq
        \\
        output~!~v \then \Skip \circseq sync \then X
      \circblockclose
    \circblockclose
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
Most notable, $SetCollisionsFromParts$ has to be decomposed. In Section~\ref{sec:Patterns}~(Pattern 3), we have already illustrated the decomposition of $SetCollisionsFromParts$ by way of the following two schema operations.
%
\begin{circusflow}
\nounparsedcolour
\begin{schema*}{InitColls}
  \Delta CDxMHState
\where
  currentFrame' = currentFrame \land state' = state \land voxel\_map' = voxel\_map \land work' = work\\
  collisions' = 0
\end{schema*}
%\extracircusvspace
%
\begin{schema*}{RecColls}
  \Delta CDxMHState\\
  collsbag? : \bag int
\where
  currentFrame' = currentFrame \land state' = state \land voxel\_map' = voxel\_map \land work' = work\\
  \exists s : \seq int | s = items ~ collsbag? @ collisions' = collisions + \Sigma ~ s
\end{schema*}
\end{circusflow}
%
We have changed their names here into $InitColls$ and $RecColls$. We have that $SetCollisionsFromParts(cb) = InitColls \circseq RecColls(cb)$. We also have the following algorithmic refinements used later on.
%
\[ InitColls \; \refby \; collisions := 0 \quad \mbox{and} \quad RecColls(\lbag colls \rbag) \; \refby \; collision := collisions + colls \]

\pagebreak

\nid The refinement of $InteractionHandlers$ thus yields.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd \dots \; \equiv \; \mbox{``decomposition of $SetCollisionsFromParts$ into an initialisation and merge operation''}
\end{circusaction*}
%
\begin{circusaction*}
  InteractionHandlers ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot detect ~ \then
    \\
    \circvar colls1, colls2, colls3, colls4 : int \circspot
    \\
    \circblockopen
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls1 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls2 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls3 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls4 := x))
    \circblockclose
    \circseq
    \\
    \circwait 0 \upto SCFP_{TB} \circseq
    \\
    \highlight{InitColls} \circseq \highlight{RecColls}(\lbag colls1, colls2, colls3, colls4 \rbag) \circseq
    \\
    output~!~collisions \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
%
\begin{circusaction*}
  \dd \dots \; \equiv \; \mbox{``multiple applications of the law~\thname{seq-op-comm} to move $InitColls$ through the sequence''}
\end{circusaction*}
%
\begin{circusaction*}
  InteractionHandlers ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot detect ~ \then
    \\
    \circvar colls1, colls2, colls3, colls4 : int \circspot \highlight{InitColls} \circseq
    \\
    \circblockopen
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls1 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls2 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls3 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls4 := x))
    \circblockclose
    \circseq
    \\
    \circwait 0 \upto SCFP_{TB} \circseq
    \\
    RecColls(\lbag colls1, colls2, colls3, colls4 \rbag) \circseq
    \\
    output~!~collisions \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
%
\begin{circusaction*}
  \dd \dots \; \equiv \; \mbox{``introduction of spurious $\circwait$ statement using the law~\thname{zero-wait-intro}''}
\end{circusaction*}
%
\begin{circusaction*}
  InteractionHandlers ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot detect ~ \then
    \\
    \circvar colls1, colls2, colls3, colls4 : int \circspot \highlight{\circwait 0} \circseq InitColls \circseq
    \\
    \circblockopen
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls1 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls2 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls3 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls4 := x))
    \circblockclose
    \circseq
    \\
    \circwait 0 \upto SCFP_{TB} \circseq
    \\
    RecColls(\lbag colls1, colls2, colls3, colls4 \rbag) \circseq
    \\
    output~!~collisions \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
Above we use a special commutativity law for data operations in the second sub-step.
%
\input{seq-op-comm.tex}
%
We also require a law to introduce a spurious $\circwait 0$ statement in order to align the shape of the action to match the left-hand side of the law. The respective law is~\thname{zero-wait-intro}, included in Appendix~\ref{app:circuslaws}.

We observe that the action $InteractionHandlers$ now has the correct shape to apply the~\thname{par-share} law. Altogether the most challenging task in the above sub-steps is the decomposition of the $SetCollisionsFromParts$ operation. In practical terms, it may be possible to define tactics that target particular schema operation shapes. The above sub-steps rely on the fact that $InitColls$ is instantaneous~(does not consume time). Dealing with cases where this assumption is not given is part of our future work.

\begin{comment}
\input{zero-wait-intro.tex}
\end{comment}
\addtocounter{circustimelawthm}{1}

\subsubsection*{Application of Pattern 3}

The application of Pattern 3 is entailed by the following refinement.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  InteractionHandlers ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot detect ~ \then
    \\
    \circvar colls1, colls2, colls3, colls4 : int \circspot \circwait 0 \circseq InitColls \circseq
    \\
    \circblockopen
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls1 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls2 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls3 := x)) ~ \circseq
      \\
      (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq colls4 := x))
    \circblockclose
    \circseq
    \\
    \circwait 0 \upto SCFP_{TB} \circseq
    \\
    RecColls(\lbag colls1, colls2, colls3, colls4 \rbag) \circseq
    \\
    output~!~collisions \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
%
\begin{circusaction*}
  \dd \dots \; \equiv \; \mbox{``application of the law~\thname{par-share}''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circmu X \circspot \highlight{initColls} \then detect \then
      \circblockopen
        (recColls~?~\anyvar \then \Skip) ~ ~ \interleave
        \\
        (recColls~?~\anyvar \then \Skip) ~ ~ \interleave
        \\
        (recColls~?~\anyvar \then \Skip) ~ ~ \interleave
        \\
        (recColls~?~\anyvar \then \Skip)
        \circblockclose
        \circseq
        output~?~\anyvar \then \Skip \circseq sync \then X
    \circblockclose
    \also
    \t1 \lpar \emptyset | \lchanset initColls, recColls, output \rchanset | \emptyset \rpar
    \also
    \color{Green}
    \circblockopen
      \circmu X \circspot
      \circblockopen
        ( \highlight{initColls} \then (\circwait 0 \circseq InitColls)) ~ ~ \extchoice
        \\
        (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq RecColls(\lbag x \rbag))) ~ ~ \extchoice
        \\
        (output~!~collisions \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \also
  \t1 \circhide ~ ~ \lchanset initColls \rchanset
\end{circusaction*}
\end{circusbox}
%
This introduces a new channel $initColls$ which corresponds to the method call that initialises $collisions$.

Although this might be an issue for the \name{AR} phase, we carry out further refinement that transforms $InitColls$ as well as the call $RecColls(\lbag x \rbag)$ into simple assignments, as previously suggested.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd \dots \; \equiv \; \mbox{``algorithmic refinement of $InitColls$ and $RecColls(\lbag x \rbag)$ and elimination of spurious $\circwait$''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circmu X \circspot initColls \then detect \then
      \circblockopen
        (recColls~?~\anyvar \then \Skip) ~ ~ \interleave
        \\
        (recColls~?~\anyvar \then \Skip) ~ ~ \interleave
        \\
        (recColls~?~\anyvar \then \Skip) ~ ~ \interleave
        \\
        (recColls~?~\anyvar \then \Skip)
        \circblockclose
        \circseq
        output~?~\anyvar \then \Skip \circseq sync \then X
    \circblockclose
    \also
    \t1 \lpar \emptyset | \lchanset initColls, recColls, output \rchanset | \emptyset \rpar
    \also
    \color{Green}
    \circblockopen
      \circmu X \circspot
      \circblockopen
        (initColls \then \highlight{collisions := 0}) ~ ~ \extchoice
        \\
        (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq \highlight{collisions := collisions + x})) ~ ~ \extchoice
        \\
        (output~!~collisions \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \also
  \t1 \circhide ~ ~ \lchanset initColls \rchanset
\end{circusaction*}
\end{circusbox}
%
The underlying $MArea$ fragment, highlighted as before in green, now has the desired shape in the program. The only remaining issue is the decomposition and distribution of the left-hand control action.

\pagebreak

\subsubsection*{Elimination of Parallel Control Action}

In order to eliminate the control action that emerged from the application of the law~\thname{par-share}, we may envisage two possible approaches. First, we may carry out manual elementary refinement steps that achieve the decomposition and distribution of the resulting smaller parallel fragments. Or otherwise, we may use a law that already entails the collapsing of (most of) the parallelism in the context of the handlers that record the results. The first approach is sketched by the refinement below that decomposes the control fragment.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circmu X \circspot initColls \then detect \then
    \circblockopen
      (recColls~?~\anyvar \then \Skip) ~ ~ \interleave
      \\
      (recColls~?~\anyvar \then \Skip) ~ ~ \interleave
      \\
      (recColls~?~\anyvar \then \Skip) ~ ~ \interleave
      \\
      (recColls~?~\anyvar \then \Skip)
      \circblockclose
      \circseq
      output~?~\anyvar \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
%
\begin{circusaction*}
  \dd \dots \; \equiv \; \mbox{``application of the law \thname{distr-rec-par-1} and elementary parallel step laws for decomposition''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circmu X \circspot initColls \then detect \circseq sync \then X
    \circblockclose
    \also
    \t1 \lpar \emptyset | \lchanset detect \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot detect \then recColls~?~\anyvar \then output~?~\anyvar \then \Skip \circseq sync \then X
    \circblockclose
    \also
    \t1 \lpar \emptyset | \lchanset detect, output \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot detect \then recColls~?~\anyvar \then output~?~\anyvar \then \Skip \circseq sync \then X
    \circblockclose
    \also
    \t1 \lpar \emptyset | \lchanset detect, output \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot detect \then recColls~?~\anyvar \then output~?~\anyvar \then \Skip \circseq sync \then X
    \circblockclose
    \also
    \t1 \lpar \emptyset | \lchanset detect, output \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot detect \then recColls~?~\anyvar \then output~?~\anyvar \then \Skip \circseq sync \then X
    \circblockclose
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
The five smaller fragments are now collapsed with suitable handlers. Whereas the first action is collapsed with the reducer handler, the remaining four actions are collapsed with the four detection handlers. Only the first action leaves a trace, namely a prefix $initColls \then \Skip$; the other actions are simply absorbed. Thus, we could encompass the collapsing of the other four fragments directly into a law that refines the control fragment that arises from the application of the \thname{par-share} law \emph{in the context} of the detection handlers. This is exactly along the lines of the modularisation in Pattern 4 via a sharing, control and design law.

\pagebreak

\nid Below we present the result after injecting the refinement of $InteractionHandlers$ and subsequently distributing the residual parallel control action~(we omit the detailed steps for decomposition and collapsing).
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circblockopen
        \circblockopen
          \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
          \\
          \green{setFrameState}~!~currentFrame~!~state \then \Skip \circseq reduce \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \also
        \circblockopen
          \circmu X \circspot reduce \then \Skip \circseq \green{getFrameState}~?~currentFrame~?~state ~ \then
          \\
          \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
          \\
          \green{setWork}~!~work \then \Skip \circseq \highlight{initColls} \then \Skip \circseq detect \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls1 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
          \\
          \green{recColls}~!~colls1 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls2 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
          \\
          \green{recColls}~!~colls2 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls3 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
          \\
          \green{recColls}~!~colls3 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls4 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
          \\
          \green{recColls}~!~colls4 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot output~?~collisions ~ \then
          \\
          \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
          \\
          (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
        \circblockclose
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset sync \rchanset | \emptyset \rpar
%      \also
      Cycle
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset setFrameState, getFrameState,
    \\
    \t2 setWork, getWork, initColls, recColls, output \rchanset | \{collisions\} \rpar
    \also
    \circblockopen
    \color{Green}
    \circblockopen
      \circvar currentFrame : RawFrame \circspot
      \\
      \circvar state : StateTable \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setFrameState~?~v_1~?~v_2 \then currentFrame, state := v_1, v_2) ~ ~ \extchoice
        \\
        (getFrameState~!~currentFrame~!~state \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \color{Black}\interleave
    \also
    \color{Green}
    \circblockopen
      \circvar work : Partition \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setWork~?~v \then work := v) ~ ~ \extchoice
        \\
        (getWork~!~work \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \color{Black}\interleave
    \also
    \color{Green}
    \circblockopen
      \circmu X \circspot
      \circblockopen
        (initColls \then collisions := 0) ~ ~ \extchoice
        \\
        (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq collisions := collisions + x)) ~ ~ \extchoice
        \\
        (output~!~collisions \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \circblockclose
  \circhide
  \also
  \t1 \lchanset reduce, detect, output, setFrameState, getFrameState, getWork, setWork, initColls, recColls, sync \rchanset
\end{circusaction*}
\end{circusbox}
%
The \highlight{highlighted} communication has been inserted into the reducer handler during the collapsing of one of the control fragments. We also observe that right-hand action now encapsulates the shared data for the $collisions$ variable. The variable declaration, however, has not been localised yet by the law.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd \dots \; \equiv \; \mbox{``application of elementary distribution laws to localised variable declarations''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circblockopen
        \circblockopen
          \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
          \\
          \green{setFrameState}~!~currentFrame~!~state \then \Skip \circseq reduce \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \also
        \circblockopen
          \circmu X \circspot reduce \then \Skip \circseq \green{getFrameState}~?~currentFrame~?~state ~ \then
          \\
          \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
          \\
          \green{setWork}~!~work \then \Skip \circseq \highlight{initColls} \then \Skip \circseq detect \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls1 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
          \\
          \green{recColls}~!~colls1 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls2 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
          \\
          \green{recColls}~!~colls2 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls3 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
          \\
          \green{recColls}~!~colls3 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls4 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
          \\
          \green{recColls}~!~colls4 \then \Skip \circseq output~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot output~?~collisions ~ \then
          \\
          \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
          \\
          (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
        \circblockclose
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset sync \rchanset | \emptyset \rpar
%      \also
      Cycle
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
    \\
    \t2 \lchanset setFrameState, getFrameState, setWork, getWork, initColls, recColls, output \rchanset | \emptyset \rpar
    \also
    \circblockopen
    \color{Green}
    \circblockopen
      \circvar currentFrame : RawFrame \circspot
      \\
      \circvar state : StateTable \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setFrameState~?~v_1~?~v_2 \then currentFrame, state := v_1, v_2) ~ ~ \extchoice
        \\
        (getFrameState~!~currentFrame~!~state \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \color{Black}\interleave
    \also
    \color{Green}
    \circblockopen
      \circvar work : Partition \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setWork~?~v \then work := v) ~ ~ \extchoice
        \\
        (getWork~!~work \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \color{Black}\interleave
    \also
    \color{Green}
    \circblockopen
      \highlight{\circvar collisions : int} \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (initColls \then collisions := 0) ~ ~ \extchoice
        \\
        (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq collisions := collisions + x)) ~ ~ \extchoice
        \\
        (output~!~collisions \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \circblockclose
  \circhide
  \also
  \t1 \lchanset reduce, detect, output, setFrameState, getFrameState, getWork, setWork, initColls, recColls, sync \rchanset
\end{circusaction*}
\end{circusbox}
%
This concludes Stage 2 of the \name{SH} phase. The refinement strategy is more  involved here, requiring several auxiliary steps before and after application of the respective high-level law. Whereas the application of Pattern 1 and Pattern 2 generally lend themselves fairly well for automation, some of the steps during the application of Pattern 3 are expected to require more guidance by and refinement effort by the developer.

The next stage targets the synchronisations on the channel $output$. This on one hand releases the output handler but also acts as a barrier for the detection handlers.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Stage 3}

Stage 3 of \name{SH} introduces shared data to refine control mechanisms that still may exist in the model. In the example, this is the the barrier-like synchronisation on $output~?~\anyvar \then \Skip$ within the detection handlers. As in the previous stage, it turns out that we cannot apply the respective law \name{barrier-sync-design} immediately but have to peform some pre-processing to transform the $System$ action into the right shape. Below we recapture the current parallelism of handlers.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circblockopen
        \circblockopen
          \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
          \\
          \green{setFrameState}~!~currentFrame~!~state \then \Skip \circseq reduce \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \also
        \circblockopen
          \circmu X \circspot reduce \then \Skip \circseq \green{getFrameState}~?~currentFrame~?~state ~ \then
          \\
          \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
          \\
          \green{setWork}~!~work \then \Skip \circseq initColls \then \Skip \circseq detect \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls1 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
          \\
          \green{recColls}~!~colls1 \then \Skip \circseq \highlight{output}~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls2 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
          \\
          \green{recColls}~!~colls2 \then \Skip \circseq \highlight{output}~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls3 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
          \\
          \green{recColls}~!~colls3 \then \Skip \circseq \highlight{output}~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls4 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
          \\
          \green{recColls}~!~colls4 \then \Skip \circseq \highlight{output}~?~\anyvar \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot \highlight{output}~?~collisions ~ \then
          \\
          \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
          \\
          (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
        \circblockclose
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset sync \rchanset | \emptyset \rpar
%      \also
      Cycle
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
    \\
    \t2 \lchanset setFrameState, getFrameState, setWork, getWork, initColls, recColls, output \rchanset | \emptyset \rpar
    \also
    \circblockopen
    \color{Green}\dots \color{Black}\interleave
    \also
    \color{Green}
    \circblockopen
      \circvar collisions : int \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (initColls \then collisions := 0) ~ ~ \extchoice
        \\
        (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq collisions := collisions + x)) ~ ~ \extchoice
        \\
        (\highlight{output}~!~collisions \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \circblockclose
  \circhide
  \also
  \t1 \lchanset reduce, detect, output, setFrameState, getFrameState, getWork, setWork, initColls, recColls, sync \rchanset
\end{circusaction*}
\end{circusbox}
%
All synchronisations on the $output$ channel are highlighted in red. This channel, like $reduce$ and $detect$ in Stage 1, fulfils a dual purpose of communicating the number of detected collisions to the output handler as well as acting as a synchronisation barrier for the detector handlers and output handler to ensure that the collisions are only communicated once all four detector handlers have committed their results. Hence, $output$ controls when the output handler is release.

Thought the scenario is somewhat similar to the one for Pattern 1, here we cannot simply apply the \name{seq-share-1} law in order to introduce the control channel for the software event that releases the output handler. For one this is because the data communicated through $output$ has already been encapsulated in Stage 2. We therefore use a different strategy outlined below.
%
\begin{enumerate}
  \item Introduce a new typeless channel $\blue{output}$ to replace the originial channel $\highlight{output}$ of type $int$ in all places where we are merely interested in the control aspect and rename $\highlight{output}$ into $\color{Green}getColls$. The new channel isolates the control aspect where $getColls$ provides the means for accessing the data.

  \item Eliminate the residual parallel fragment results from the above introduction.

  \item Use the \name{synch-barrier-design} law to refine the barrier synchronisation mechanism.
\end{enumerate}
%
To proceed with (1) we require a specialised channel replacement law. Possibly, this law can be specified in a more general manner, for instance, by some inductively-defined substitution procedure. Essentially, it replaces occurrences of prefixes of the form $\highlight{output}~?~x \then A$ by simple prefixes $\blue{outout} \then A$ where $x$ is not used in $A$ and otherwise by $getColls~?~x \then A$. This replacement is justified by two facts.
%
\begin{enumerate}
  \item The original channel $\highlight{output}$ is concealed in the system action.

  \item Inclusion of an additional parallel control fragment:
  %
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circmu X \circspot \blue{output} \then \green{getColls}~?~\anyvar \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction*}
\end{circusbox}
\end{enumerate}
%
The control fragment is expected to be eliminated in the usual way. Here, this is collapsing it with the handler that outputs the collisions. The local refinement for this transformation is given below.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circmu X \circspot \green{getColls}~?~collisions ~ \then
      \\
      \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
      \\
      (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
    \circblockclose
    \also
    \t1 \lpar \emptyset | \lchanset getColls \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \circmu X \circspot \blue{output} \then \green{getColls}~?~\anyvar \then \Skip \circseq sync \then X
    \circblockclose
  \circblockclose
\end{circusaction*}
%
\begin{circusaction*}
  \dd \refby \; \mbox{``distributing recursion in the parallel actions and collapsing the parallelism using step laws''}
\end{circusaction*}
%
\begin{circusaction*}
    \circblockopen
      \circmu X \circspot \blue{output} \then \green{getColls}~?~collisions ~ \then
      \\
      \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
      \\
      (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
    \circblockclose
\end{circusaction*}
\end{circusbox}
%
The collapsing of parallelism introduces the prefix $\blue{output} \then \dots\;$' into the output handler and thereby establishes the desired design in which $\blue{output}$ acts as a software event that releases this handler.

The above refinement, as noted, rests on a channel replacement law that, however, will not be discussed in more detail here; instead, we just present the $System$ action that we expect to result from its application.

\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd \refby \; \mbox{``specialised channel replacement law and distributing residual parallel control action''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circblockopen
        \circblockopen
          \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
          \\
          \green{setFrameState}~!~currentFrame~!~state \then \Skip \circseq reduce \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \also
        \circblockopen
          \circmu X \circspot reduce \then \Skip \circseq \green{getFrameState}~?~currentFrame~?~state ~ \then
          \\
          \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
          \\
          \green{setWork}~!~work \then \Skip \circseq initColls \then \Skip \circseq detect \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls1 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
          \\
          \green{recColls}~!~colls1 \then \Skip \circseq \blue{output} \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls2 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
          \\
          \green{recColls}~!~colls2 \then \Skip \circseq \blue{output} \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls3 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
          \\
          \green{recColls}~!~colls3 \then \Skip \circseq \blue{output} \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls4 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
          \\
          \green{recColls}~!~colls4 \then \Skip \circseq \blue{output} \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot \blue{output} \then \green{getColls}~?~collisions ~ \then
          \\
          \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
          \\
          (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
        \circblockclose
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset sync \rchanset | \emptyset \rpar
%      \also
      Cycle
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
    \also
    \t2 \lchanset [set/get]FrameState, [set/get]Work, initColls, recColls, getColls, output \rchanset | \emptyset \rpar
    \also
    \circblockopen
    \color{Green}
    \circblockopen
      \circvar currentFrame : RawFrame \circspot
      \\
      \circvar state : StateTable \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setFrameState~?~v_1~?~v_2 \then currentFrame, state := v_1, v_2) ~ ~ \extchoice
        \\
        (getFrameState~!~currentFrame~!~state \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \color{Black}\interleave
    \also
    \color{Green}
    \circblockopen
      \circvar work : Partition \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setWork~?~v \then work := v) ~ ~ \extchoice
        \\
        (getWork~!~work \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \color{Black}\interleave
    \also
    \color{Green}
    \circblockopen
      \circvar collisions : int \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (initColls \then collisions := 0) ~ ~ \extchoice
        \\
        (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq collisions := collisions + x)) ~ ~ \extchoice
        \\
        (getColls~!~collisions \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \circblockclose
  \circhide
  \also
  \t1 \lchanset reduce, detect, output, [set/get]FrameState, [set/get]Work, initColls, recColls, getColls, sync \rchanset
\end{circusaction*}
\end{circusbox}
%
We obersve the new channels $\blue{output}$ and $\green{getColls}$. Moreover, all channels used int the right-hand parallel action that encapsulates shared data are now channels that model either method calls or direct access to shared variables. We now proceed applying the law \thname{sync-barrier-design}.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \circblockopen
    \circblockopen
    \circblockopen
      \circblockopen
        \circblockopen
          \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
          \\
          \green{setFrameState}~!~currentFrame~!~state \then \Skip \circseq reduce \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \also
        \circblockopen
          \circmu X \circspot reduce \then \Skip \circseq \green{getFrameState}~?~currentFrame~?~state ~ \then
          \\
          \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq
          \\
          \green{setWork}~!~work \then \Skip \circseq initColls \then \Skip \circseq detect \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls1 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
          \\
          \green{recColls}~!~colls1 \then \Skip \circseq \highlight{notify}~!~1 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls2 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
          \\
          \green{recColls}~!~colls2 \then \Skip \circseq \highlight{notify}~!~2 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls3 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
          \\
          \green{recColls}~!~colls3 \then \Skip \circseq \highlight{notify}~!~3 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls4 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
          \\
          \green{recColls}~!~colls4 \then \Skip \circseq \highlight{notify}~!~4 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot output \then \green{getColls}~?~collisions ~ \then
          \\
          \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
          \\
          (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
        \circblockclose
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset sync \rchanset | \emptyset \rpar
%      \also
      Cycle
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset detect, start, sync \rchanset | \emptyset \rpar
    \also
    \circblockopen
      \highlight{\circmu X \circspot start \then detect \then \Skip \circseq sync \then X}
    \circblockclose
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
    \also
    \t2 \lchanset [set/get]FrameState, [set/get]Work, initColls, recColls, getColls \rchanset | \emptyset \rpar
    \also
    \circblockopen
    \color{Green}\dots
    \color{Black}\interleave
    \also
    \color{Green}
    \circblockopen
      \circvar active : \power ~ (1 \upto n) \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (start \then active := 1 \upto n)
        \\
        \t1 \extchoice
        \\
        (notify~?~x \then
        \circblockopen
          active := active \setdiff \{x\} \circseq
          \\
          \circif active = \emptyset \circthen output \then \Skip\\
          \circelse ~ \lnot active = \emptyset \circthen \Skip\\
          \circfi
        \circblockclose)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \circblockclose
  \also
  \dd \lchanset reduce, detect, output, start, notify, [set/get]FrameState, [set/get]Work, initColls, recColls, getColls, sync \rchanset
\end{circusaction*}
\end{circusbox}
%
Once again a control fragment arises as a consequence of applying the law. We distribute it into the reducer handler. This gives rise to the following $System$ action.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd \refby \; \mbox{``distribution of control fragment using parallel step laws''}
\end{circusaction*}
%
\begin{circusaction*}
  \circblockopen
    \circblockopen
      \circblockopen
        \circblockopen
          \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
          \\
          \green{setFrameState}~!~currentFrame~!~state \then \Skip \circseq reduce \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \also
        \circblockopen
          \circmu X \circspot reduce \then \Skip \circseq \green{getFrameState}~?~currentFrame~?~state ~ \then
          \\
          \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq \green{setWork}~!~work \then \Skip \circseq
          \\
          initColls \then \Skip \circseq \highlight{start \then \Skip} \circseq detect \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls1 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
          \\
          \green{recColls}~!~colls1 \then \Skip \circseq notify~!~1 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls2 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
          \\
          \green{recColls}~!~colls2 \then \Skip \circseq notify~!~2 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls3 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
          \\
          \green{recColls}~!~colls3 \then \Skip \circseq notify~!~3 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq \green{getWork}~?~work \then \circvar colls4 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
          \\
          \green{recColls}~!~colls4 \then \Skip \circseq notify~!~4 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot output \then \green{getColls}~?~collisions ~ \then
          \\
          \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
          \\
          (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
        \circblockclose
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset sync \rchanset | \emptyset \rpar
%      \also
      Cycle
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
    \also
    \t2 \lchanset [set/get]FrameState, [set/get]Work, initColls, recColls, getColls, output \rchanset | \emptyset \rpar
    \also
    \circblockopen
    \color{Green}\dots
    \color{Black}\interleave
    \also
    \color{Green}
    \circblockopen
      \circvar active : \power ~ (1 \upto n) \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (start \then active := 1 \upto n)
        \\
        \t1 \extchoice
        \\
        (notify~?~x \then
        \circblockopen
          active := active \setdiff \{x\} \circseq
          \\
          \circif active = \emptyset \circthen output \then \Skip\\
          \circelse ~ \lnot active = \emptyset \circthen \Skip\\
          \circfi
        \circblockclose)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
  \circblockclose
  \circhide
  \also
  \dd \lchanset reduce, detect, output, start, notify, [set/get]FrameState, [set/get]Work, initColls, recColls, getColls, sync \rchanset
\end{circusaction*}
\end{circusbox} 
%
This concludes Stage 3. All remaining control behaviour has been removed and as a result, additional shared data was introduced. In the next and last stage of the \name{SH} phase we factor out the $MArea$ action and collapse parallelism between actions that encapsulate shared data in the same object in the program.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Stage 4}

The encapsulated data that has emerged is now extracted in a separate local action $MArea$.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  MArea ~ \circdef\\
  \t1
  \circblockopen
    \circblockopen
      \circvar currentFrame : RawFrame \circspot
      \\
      \circvar state : StateTable \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setFrameState~?~v_1~?~v_2 \then currentFrame, state := v_1, v_2) ~ ~ \extchoice
        \\
        (getFrameState~!~currentFrame~!~state \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \interleave
    \also
    \circblockopen
      \circvar work : Partition \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setWork~?~v \then work := v) ~ ~ \extchoice
        \\
        (getWork~!~work \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \interleave
    \also
    \circblockopen
      \circvar collisions : int \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (initColls \then collisions := 0) ~ ~ \extchoice
        \\
        (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq collisions := collisions + x)) ~ ~ \extchoice
        \\
        (getColls~!~collisions \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \interleave
    \also
    \circblockopen
      \circvar active : \power ~ (1 \upto n) \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (start \then active := 1 \upto n)
        \\
        \t1 \extchoice
        \\
        (notify~?~x \then
        \circblockopen
          active := active \setdiff \{x\} \circseq
          \\
          \circif active = \emptyset \circthen output \then \Skip\\
          \circelse ~ \lnot active = \emptyset \circthen \Skip\\
          \circfi
        \circblockclose)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
Because the shared variables $currentFrame$, $state$, $work$ and $collisions$ are fields of the same object in the program~(class \verb"CDxMission"), we collapse the parallelism of recursions into a single recursion to reflect that the underlying methods synchronise on a common lock.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  \dd \refby \; \mbox{``specialised laws to collapse parallelisms of recursions in $MArea$''}
\end{circusaction*}
%
\begin{circusaction*}
  MArea ~ \circdef\\
  \t1
  \circblockopen
    \circblockopen
      \circvar currentFrame : RawFrame \circspot
      \\
      \circvar state : StateTable \circspot
      \\
      \circvar work : Partition \circspot
      \\
      \circvar collisions : int \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setFrameState~?~v_1~?~v_2 \then currentFrame, state := v_1, v_2) ~ ~ \extchoice
        \\
        (getFrameState~!~currentFrame~!~state \then \Skip) ~ ~ \extchoice
        \\
        (setWork~?~v \then work := v) ~ ~ \extchoice
        \\
        (getWork~!~work \then \Skip) ~ ~ \extchoice
        \\
        (initColls \then collisions := 0) ~ ~ \extchoice
        \\
        (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq collisions := collisions + x)) ~ ~ \extchoice
        \\
        (getColls~!~collisions \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \interleave
    \also
    \circblockopen
      \circvar active : \power ~ (1 \upto n) \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (start \then active := 1 \upto n)
        \\
        \t1 \extchoice
        \\
        (notify~?~x \then
        \circblockopen
          active := active \setdiff \{x\} \circseq
          \\
          \circif active = \emptyset \circthen output \then \Skip\\
          \circelse ~ \lnot active = \emptyset \circthen \Skip\\
          \circfi
        \circblockclose)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
\end{circusaction*}
\end{circusbox}
%
The precise laws needed for the above refinement are future work and furthermore they are in general likely to be non-compositional. Namely, because collapsing parallelism above results in an action that is less willing to communicate in that nondeterministic waits may be introduced. Above, that is $\circwait 0 \upto RC_{TB}$. The refinement may be justified by reducing time budgets in other places but this is future work.
\medskip

\nid For the $System$ action we obtain the following definition.
%
\begin{circusbox}
\nounparsedcolour
\begin{circusaction*}
  System ~ \circdef\\
  \t1
  \circblockopen
    \circblockopen
      \circblockopen
        \circblockopen
          \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
          \\
          setFrameState~!~currentFrame~!~state \then \Skip \circseq reduce \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \also
        \circblockopen
          \circmu X \circspot reduce \then \Skip \circseq getFrameState~?~currentFrame~?~state ~ \then
          \\
          \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq setWork~!~work \then \Skip \circseq
          \\
          initColls \then \Skip \circseq start \then \Skip \circseq detect \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq getWork~?~work \then \circvar colls1 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls1 / pcolls!] \land i? = 1) \rschexpract \circseq
          \\
          recColls~!~colls1 \then \Skip \circseq notify~!~1 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq getWork~?~work \then \circvar colls2 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls2 / pcolls!] \land i? = 2) \rschexpract \circseq
          \\
          recColls~!~colls2 \then \Skip \circseq notify~!~2 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq getWork~?~work \then \circvar colls3 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls3 / pcolls!] \land i? = 3) \rschexpract \circseq
          \\
          recColls~!~colls3 \then \Skip \circseq notify~!~3 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset detect, output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot detect \then \Skip \circseq getWork~?~work \then \circvar colls4 : int \circspot
          \\
          \circwait 0 \upto CPC_{TB} \circseq \lschexpract (\exists i? : \num @ CalcPartCollisions[colls4 / pcolls!] \land i? = 4) \rschexpract \circseq
          \\
          recColls~!~colls4 \then \Skip \circseq notify~!~4 \then \Skip \circseq sync \then X
        \circblockclose
        \also
        \t1 \lpar \emptyset | \lchanset output, sync \rchanset | \emptyset \rpar
        \also
        \circblockopen
          \circmu X \circspot output \then getColls~?~collisions ~ \then
          \\
          \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
          \\
          (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
        \circblockclose
      \circblockclose
      \also
      \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset sync \rchanset | \emptyset \rpar
%      \also
      Cycle
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
    \also
    \t2 \lchanset [set/get]FrameState, [set/get]Work, initColls, recColls, getColls, output \rchanset | \emptyset \rpar
    \also
    \highlight{MArea}
  \circblockclose
  \circhide
  \also
  \t2 \lchanset reduce, detect, output, start, notify, [set/get]FrameState, [set/get]Work, initColls, recColls,
  \also
  \t3 getColls, sync \rchanset
\end{circusaction*}
\end{circusbox}
%
This concludes Stage 4 and thereby the \name{SH} phase. We finally present the entire process for \name{SH}.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection{Process}

%%Zword \reduce {reducesh}
%%Zword \detect {detectsh}
%%Zword \output {outputsh}

\newcommand{\reduce}{reduce}
\newcommand{\detect}{detect}
\renewcommand{\output}{output}

\begin{comment}
\begin{circus}
  \circchannel ~ setFrameState : RawFrame \cross StateTable
  \also
  \circchannel ~ getFrameState : RawFrame \cross StateTable
  \also
  \circchannel ~ getWork : Partition
  \also
  \circchannel ~ setWork : Partition
  \also
  \circchannel ~ initColls
  \also
  \circchannel ~ getColls : int
  \also
  \circchannel ~ start
  \also
  \circchannel ~ notify : int
  \also
  \circchannel ~ \reduce, \detect, \output
\end{circus}
\end{comment}

\nid The complete process for the \name{SH} phase is presented below. Its state and data operations are in fact the same as those of $CDxE\_MH$, apart from $SetCollisionsFromParts$ having been removed.
%
\begin{circusflow}
\begin{circus}
  \circsystem ~ CDxE\_SH ~ \circdef ~ \circbegin
\end{circus}
%
\begin{comment}
\begin{schema}{\circstateignore ~ CDxMHState}
  currentFrame : RawFrame\\
  state : StateTable\\
  voxel\_map : HashMap[Vector2d,List[Motion]]\\
  work : Partition\\
  collisions : int
\end{schema}
\end{comment}
%
\begin{circusaction}
  \circstate ~ CDxSHState ~ == ~ CDxMHState
\end{circusaction}
%
\begin{schema}{Init}
 CDxSHState~'
\where
  currentFrame' = \circnew RawFrame
  \\
  state' = \circnew StateTable
  \\
  voxel\_map' = \circnew HashMap[Vector2d,List[Motion]]
  \\
  work' = \circnew Partition \argfour
  \\
  collisions' = 0
\end{schema}
%
\begin{schema}{StoreFrame}
  \Delta CDxSHState\\
  frame? : Frame
\where
  \exists posns, posns' : Frame; motions, motions' : Frame |\\
  \t1 \dom posns = \dom motions \land \dom posns' = \dom motions' @\\
  \circblockopen
  posns' = frame? \land
  \\
  motions' =\\
  \t1 \{a : \dom posns' @ a \mapsto \IF a \in \dom posns \THEN (posns' ~ a) \vminus (posns ~ a) \ELSE ZeroV\} \land
  \\
  posns = F(currentFrame) \land motions = G(currentFrame, state) \land
  \\
  posns' = F(currentFrame') \land motions' = G(currentFrame', state')
  \circblockclose
\end{schema}
%
\begin{schema}{ReduceAndPartitionWork}
  \Delta CDxSHState\\
\where
  currentFrame' = currentFrame \land state' = state
  \\
  \exists posns : Frame; motions : Frame | \dom posns = \dom motions @\\
  \circblockopen
  posns = F(currentFrame) \land motions = G(currentFrame, state) \land
  \also
  \circblockopen
    \forall a_1, a_2 : Aircraft | \{a_1, a_2\} \subseteq \dom posns @
    \\
    \t1 (a_1, a_2) \in CalcCollisionSet(posns, motions) \implies
    \\
    \t2
    \circblockopen
      \exists l : List[Motion] |
      l \in \hidemath{(}voxel\_map'~.~values~\emptytuple\hidemath{)}~.~elems~\emptytuple @\\
      \t1 MkMotion(a_1, posns~a_1 \vminus motions~a_1, posns~a_1) \in l~.~elems~\emptytuple \land\\
      \t1 MkMotion(a_2, posns~a_2 \vminus motions~a_2, posns~a_2) \in l~.~elems~\emptytuple
    \circblockclose
  \circblockclose
  \circblockclose
\end{schema}
%
\begin{schema}{CalcPartCollisions}
  \Xi CDxSHState\\
  pcolls! : int\\
  i? : 1 \upto 4
\where
  pcolls! ~ =\\
  \t1 \#
  \biglcurly
    a_1 : Aircraft; a_2 : Aircraft |\\
    \t1
    \circblockopen
      \exists l : List[Motion] | l \in \hidemath{(}work~.~getDetectorWork(i?)\hidemath{)}.~elems~\emptytuple @\\
      \exists v_1, v_2 : Vector; w_1, w_2 : Vector @\\
      \t1 MkMotion(a_1, v_1, w_1) \in l~.~elems~\emptytuple \land\\
      \t1 MkMotion(a_2, v_2, w_2) \in l~.~elems~\emptytuple \land\\
      \t1 collide((v_1, w_1 \vminus v_1), (v_2, w_2 \vminus v_2))
    \circblockclose
  \bigrcurly
  \div 2
\end{schema}
%
\begin{schema}{CalcCollisions}
  \Xi CDxSHState\\
  colls! : \nat
\where
  \exists posns : Frame; motions : Frame | \dom posns = \dom motions @\\
  \circblockopen
  posns = F(currentFrame) \land motions = G(currentFrame, state) \land
  \also
  \exists collset : \finset ~ (Aircraft \cross Aircraft) | collset = CalcCollisionSet(posns, motions) @
  \\
  \t1 (\# collset = 0 \land colls! = 0) \lor (\# collset > 0 \land colls! \geq (\# collset) \div 2)
  \circblockclose
\end{schema}
%
\begin{circusaction}
  InputFrameHandler ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot (next\_frame~?~frame \then (\circwait 0 \upto SF_{TB} \circseq StoreFrame)) \circdeadlinesync INP\_DL \circseq
    \\
    setFrameState~!~currentFrame~!~state \then \Skip \circseq \reduce \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction}
\extracircusvspace
%
\begin{circusaction}
  ReducerHandler ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot \reduce \then \Skip \circseq getFrameState~?~currentFrame~?~state ~ \then
    \\
    \circwait 0 \upto RPW_{TB} \circseq \lschexpract ReduceAndPartitionWork \rschexpract \circseq setWork~!~work \then \Skip \circseq
    \\
    initColls \then \Skip \circseq start \then \Skip \circseq \detect \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction}
%
\begin{circusaction}
  DetectorHandler1 ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot \detect \then \Skip \circseq getWork~?~work \then \circvar colls1 : int \circspot
    \\
    \circwait 0 \upto CPC_{TB} \circseq \CPCONE \circseq
    \\
    recColls~!~colls1 \then \Skip \circseq notify~!~1 \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction}
%
\begin{circusaction}
  DetectorHandler2 ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot \detect \then \Skip \circseq getWork~?~work \then \circvar colls2 : int \circspot
    \\
    \circwait 0 \upto CPC_{TB} \circseq \CPCTWO \circseq
    \\
    recColls~!~colls2 \then \Skip \circseq notify~!~2 \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction}
%
\begin{circusaction}
  DetectorHandler3 ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot \detect \then \Skip \circseq getWork~?~work \then \circvar colls3 : int \circspot
    \\
    \circwait 0 \upto CPC_{TB} \circseq \CPCTHREE \circseq
    \\
    recColls~!~colls3 \then \Skip \circseq notify~!~3 \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction}
%
\begin{circusaction}
  DetectorHandler4 ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot \detect \then \Skip \circseq getWork~?~work \then \circvar colls4 : int \circspot
    \\
    \circwait 0 \upto CPC_{TB} \circseq \CPCFOUR \circseq
    \\
    recColls~!~colls4 \then \Skip \circseq notify~!~4 \then \Skip \circseq sync \then X
  \circblockclose
\end{circusaction}
%
\begin{circusaction}
  OutputCollisionsHandler ~ \circdef\\
  \t1
  \circblockopen
    \circmu X \circspot \output \then getColls~?~collisions ~ \then
    \\
    \circvar colls : int \circspot \circwait 0 \upto CC_{TB} \circseq \lschexpract CalcCollisions \rschexpract \circseq
    \\
    (output\_collisions~!~colls \then \Skip) \circdeadlinesync OUT\_DL \circseq sync \then X
  \circblockclose
\end{circusaction}
%
\begin{circusaction}
  Cycle ~ \circdef ~
  \circblockopen
    \circmu X \circspot \circwait FRAME\_PERIOD \circseq sync \then X
  \circblockclose
\end{circusaction}
%
% FIX: Had to add parenthesis to the handler parallelism to enable correct parsing.
%
\begin{circusaction}
  System ~ \circdef\\
  \t1
  \circblockopen
    \circblockopen
      \circblockopen
        InputFrameHandler
        \\
        \t1 \lpar \{currentFrame, state\} | \lchanset reduce, sync \rchanset | \{voxel\_map, work\} \rpar
        \\
        (ReducerHandler
        \\
        \t1 \lpar \{voxel\_map, work\} | \lchanset detect, sync \rchanset | \emptyset \rpar
        \\
        (DetectorHandler1
        \\
        \t1 \lpar \emptyset | \lchanset detect,sync \rchanset | \emptyset \rpar
        \\
        (DetectorHandler2
        \\
        \t1 \lpar \emptyset | \lchanset detect, sync \rchanset | \emptyset \rpar
        \\
        (DetectorHandler3
        \\
        \t1 \lpar \emptyset | \lchanset detect, sync \rchanset | \emptyset \rpar
        \\
        (DetectorHandler4
        \\
        \t1 \lpar \emptyset | \lchanset sync \rchanset | \emptyset \rpar
        \\
        OutputCollisionsHandler)))))
      \circblockclose
    \circblockclose
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work\} | \lchanset sync \rchanset | \emptyset \rpar
%    \also
    Cycle
  \circblockclose
  \circhide
  \also
  \t2 \lchanset \reduce, \detect, \output, start, notify, sync,
  \also
  \t3 setFrameState, getFrameState, setWork, getWork, initColls, recColls, getColls \rchanset
\end{circusaction}
%
% FIX: Had to replace parallel assignment.
%
% FIX: Had to change $n$ into 4. Check this is changed earlier on too.
%
\begin{circusaction}
  MArea ~ \circdef\\
  \t1
  \circblockopen
    \circblockopen
      \circvar currentFrame : RawFrame \circspot
      \\
      \circvar state : StateTable \circspot
      \\
      \circvar work : Partition \circspot
      \\
      \circvar collisions : int \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (setFrameState~?~v1~?~v2 \then (currentFrame := v1 \circseq state := v2)) ~ ~ \extchoice
        \\
        (getFrameState~!~currentFrame~!~state \then \Skip) ~ ~ \extchoice
        \\
        (setWork~?~v \then work := v) ~ ~ \extchoice
        \\
        (getWork~!~work \then \Skip) ~ ~ \extchoice
        \\
        (initColls \then collisions := 0) ~ ~ \extchoice
        \\
        (recColls~?~x \then (\circwait 0 \upto RC_{TB} \circseq collisions := collisions + x)) ~ ~ \extchoice
        \\
        (getColls~!~collisions \then \Skip)
      \circblockclose
      \circseq X
    \circblockclose
    \interleave
    \also
    \circblockopen
      \circvar active : \power ~ (1 \upto 4) \circspot
      \\
      \t1 \circmu X \circspot
      \circblockopen
        (start \then active := \{1, 2, 3, 4\})
        \\
        \t1 \extchoice
        \\
        (notify~?~x \then
        \circblockopen
          active := active \setminus \{x\} \circseq
          \\
          \circif active = \emptyset \circthen \output \then \Skip\\
          \circelse ~ \lnot active = \emptyset \circthen \Skip\\
          \circfi
        \circblockclose)
      \circblockclose
      \circseq X
    \circblockclose
  \circblockclose
\end{circusaction}
%
\begin{circusaction}
  \circspot \lschexpract Init \rschexpract \circseq
  \circblockopen
    System
    \also
    \t1 \lpar \{currentFrame, state, voxel\_map, work\} |
    \also
    \t2 \lchanset setFrameState, getFrameState, setWork, getWork,
    \also
    \t3 initColls, recColls, getColls, start, notify, sync \rchanset | \emptyset \rpar
    \also
    MArea
  \circblockclose
\end{circusaction}
%
\begin{circus}
  \circend
\end{circus}
\end{circusflow}
%
Parts of the process that could not be parsed due to limitations of the {\Circus} parser in CZT are highlighted.
